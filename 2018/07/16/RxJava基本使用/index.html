<!DOCTYPE HTML>
<html lang="zh-tw">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="lee">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>RxJava基本使用 | lee</title>


    <link rel="alternate" href="/atom.xml" title="lee" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='lee'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">lee</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/android/"><i class="fa "></i>android</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/python/"><i class="fa "></i>Python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="RxJava基本使用">
            
	            RxJava基本使用
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/android">
            android
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/07/16</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>###RxJava是什么?</p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">开源地址</a></p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">RxAndroid</a></p>
<blockquote>
</blockquote>
<p>要知道RxJava是什么，那么你应该先去了解一下Rx。Rx的全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。Rx已经渗透到了各个语言中，有了Rx所以才有了 RxJava，Rx.NET、RxJS、RxSwift、Rx.rb、RxPHP等等</p>
<blockquote>
</blockquote>
<p>官方描述 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）</p>
<ul>
<li>RXJava 是基于观察者模式构建的</li>
</ul>
<p>我们先把观察者模式说清楚 例如：“按下开关，台灯灯亮”</p>
<p>在这个事件中，台灯作为观察者，开关作为被观察者，台灯透过电线来观察开关的状态来并做出相应的处理</p>
<p><img src="https://pic4.zhimg.com/80/v2-6d47c3fafb124576fc12e1206824512b_hd.png" alt=""></p>
<ul>
<li>开关（被观察者）作为事件的产生方（生产“开”和“关”这两个事件），是主动的，是整个开灯事理流程的起点。</li>
<li>台灯（观察者）作为事件的处理方（处理“灯亮”和“灯灭”这两个事件），是被动的，是整个开灯事件流程的终点。</li>
<li>在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的（上图没有体现，后面对会讲到）。</li>
</ul>
<p>###响应式编程是什么？</p>
<blockquote>
</blockquote>
<p>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>
<blockquote>
</blockquote>
<p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。</p>
<p>###RxJava好在哪？<br>例如：从服务器上拉去最新小区列表的需求，可能这样写：</p>
<pre><code>new Thread() {
        @Override
        public void run() {
            super.run();
            //从服务端获取小区列表
            List&lt;Community&gt; communities = getCommunitiesFromServer();
            for (Community community : communities) {
                List&lt;House&gt; houses = community.houses;
                for (House house : houses) {
                    if (house.price &gt;= 5000000) {
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                //将房子的信息添加到屏幕上
                                addHouseInformationToScreen(house);
                            }
                        });
                    }
                }
            }
        }
    }.start();
</code></pre><p>RxJava 这样写：</p>
<pre><code>Observable.from(getCommunitiesFromServer())
            .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() {
                @Override
                public Observable&lt;House&gt; call(Community community) {
                    return Observable.from(community.houses);
                }
            }).filter(new Func1&lt;House, Boolean&gt;() {
                @Override
                public Boolean call(House house) {
                    return house.price&gt;=5000000;
                }
            }).subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Action1&lt;House&gt;() {
                @Override
                public void call(House house) {
                    //将房子的信息添加到屏幕上
                    addHouseInformationToScreen(house);
                }
            });
</code></pre><p>Lambda 简化：</p>
<pre><code>Observable.from(getCommunitiesFromServer())
            .flatMap(community -&gt; Observable.from(community.houses))
            .filter(house -&gt; house.price&gt;=5000000).subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(this::addHouseInformationToScreen);
</code></pre><p>###RxJava基本元素</p>
<p>###RxJava基本使用</p>
<p>####操作符<br><a href="http://reactivex.io/documentation/operators.html#creating" target="_blank" rel="noopener">Create</a></p>
<blockquote>
</blockquote>
<p>create 操作符应该是最常见的操作符了，主要用于产生一个 Obserable 被观察者对象，为了方便大家的认知，以后的教程中统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。</p>
<p><img src="http://reactivex.io/documentation/operators/images/create.c.png" alt=""></p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {
                Log.e(TAG, &quot;Observable emit 1&quot; + &quot;\n&quot;);
                e.onNext(1);
                Log.e(TAG, &quot;Observable emit 2&quot; + &quot;\n&quot;);
                e.onNext(2);
                Log.e(TAG, &quot;Observable emit 3&quot; + &quot;\n&quot;);
                e.onNext(3);
                e.onComplete();
                Log.e(TAG, &quot;Observable emit 4&quot; + &quot;\n&quot; );
                e.onNext(4);
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            private int i;
            private Disposable mDisposable;

            @Override
            public void onSubscribe(@NonNull Disposable d) {
                Log.e(TAG, &quot;onSubscribe : &quot; + d.isDisposed() + &quot;\n&quot; );
                mDisposable = d;
            }

            @Override
            public void onNext(@NonNull Integer integer) {
                Log.e(TAG, &quot;onNext : value : &quot; + integer + &quot;\n&quot; );
                i++;
                if (i == 2) {
                    // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件
                    mDisposable.dispose();
                    Log.e(TAG, &quot;onNext : isDisposable : &quot; + mDisposable.isDisposed() + &quot;\n&quot;);
                }
            }

            @Override
            public void onError(@NonNull Throwable e) {
                Log.e(TAG, &quot;onError : value : &quot; + e.getMessage() + &quot;\n&quot; );
            }

            @Override
            public void onComplete() {
                Log.e(TAG, &quot;onComplete&quot; + &quot;\n&quot; );
            }
        });

结果：
onSubscribe : false
Observable emit 1
onNext : value : 1
Observable emit 2
onNext : value : 2
onNext : isDisposable : true
Observable emit 3
Observable emit 4
</code></pre><p><a href="http://reactivex.io/documentation/operators/map.html" target="_blank" rel="noopener">Map</a></p>
<blockquote>
</blockquote>
<p>它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-002d843b658b98e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt=""></p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {
                e.onNext(1);
                e.onNext(2);
                e.onNext(3);
            }
        }).map(new Function&lt;Integer, String&gt;() {
            @Override
            public String apply(@NonNull Integer integer) throws Exception {
                return &quot;This is result &quot; + integer;
            }
        }).subscribe(new Consumer&lt;String&gt;() {
            @Override
            public void accept(@NonNull String s) throws Exception {
                mRxOperatorsText.append(&quot;accept : &quot; + s +&quot;\n&quot;);
                Log.e(TAG, &quot;accept : &quot; + s +&quot;\n&quot; );
            }
        });

结果：
07-10 14:15:49.857 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 1
07-10 14:15:49.859 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 2
07-10 14:15:49.861 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 3
</code></pre><p>###<a href="http://reactivex.io/documentation/operators/concat.html" target="_blank" rel="noopener">Concat</a></p>
<p>简单来说就是连接两个或多个发射器，向一个发射器一样，他们不产生交叉<br><img src="https://upload-images.jianshu.io/upload_images/3994917-717b7a5bae136a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/610" alt=""></p>
<pre><code>  Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6))
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        Log.e(TAG, &quot;concat : &quot;+ integer + &quot;\n&quot; );
                    }
                });

执行结果： 
07-10 14:24:10.147 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 1
07-10 14:24:10.150 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 2
07-10 14:24:10.154 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 3
07-10 14:24:10.158 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 4
07-10 14:24:10.162 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 5
07-10 14:24:10.166 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 6
</code></pre><p>###<a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">FlatMap</a></p>
<blockquote>
</blockquote>
<p>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</p>
<p><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt=""></p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
           @Override
           public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {
               e.onNext(1);
               e.onNext(2);
               e.onNext(3);
           }
       }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {
           @Override
           public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception {
               List&lt;String&gt; list = new ArrayList&lt;&gt;();
               for (int i = 0; i &lt; 3; i++) {
                   list.add(&quot;I am value &quot; + integer);
               }
               int delayTime = (int) (1 + Math.random() * 10);
               return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS);
           }
       }).subscribeOn(Schedulers.newThread())
               .observeOn(AndroidSchedulers.mainThread())
               .subscribe(new Consumer&lt;String&gt;() {
                   @Override
                   public void accept(@NonNull String s) throws Exception {
                       Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\n&quot;);
                       mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\n&quot;);
                   }
               });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-24acfeb6e4f70ec4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>###<a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">ConcatMap</a></p>
<blockquote>
</blockquote>
<p>concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证吧</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {
                e.onNext(1);
                e.onNext(2);
                e.onNext(3);
            }
        }).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {
            @Override
            public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception {
                List&lt;String&gt; list = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; 3; i++) {
                    list.add(&quot;I am value &quot; + integer);
                }
                int delayTime = (int) (1 + Math.random() * 10);
                return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS);
            }
        }).subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;String&gt;() {
                    @Override
                    public void accept(@NonNull String s) throws Exception {
                        Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\n&quot;);
                        mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\n&quot;);
                    }
                });
</code></pre><p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-f619ff85cd5199e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>###<a href="https://upload-images.jianshu.io/upload_images/3994917-6b58db3710558ca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" target="_blank" rel="noopener">Distinct</a></p>
<p>顾名思义，去重操作符</p>
<pre><code>Observable.just(1, 1, 1, 2, 2, 3, 4, 5)
                .distinct()
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\n&quot;);
                        Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\n&quot;);
                    }
                });
</code></pre><p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-9a9500abebd6097b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>###<a href="http://reactivex.io/documentation/operators/filter.html" target="_blank" rel="noopener">Filter</a></p>
<blockquote>
</blockquote>
<p>emit only those items from an Observable that pass a predicate test</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-cbb8917000cd55fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt=""></p>
<pre><code>Observable.just(1, 20, 65, -5, 7, 19)
                .filter(new Predicate&lt;Integer&gt;() {
                    @Override
                    public boolean test(@NonNull Integer integer) throws Exception {
                        return integer &gt;= 10;
                    }
                }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(@NonNull Integer integer) throws Exception {
                mRxOperatorsText.append(&quot;filter : &quot; + integer + &quot;\n&quot;);
                Log.e(TAG, &quot;filter : &quot; + integer + &quot;\n&quot;);
            }
        });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-c5cfda2812d122fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>###<a href="http://reactivex.io/documentation/operators/just.html" target="_blank" rel="noopener">just</a></p>
<p>就是一个简单的发射器依次调用 onNext() 方法。<br><img src="https://upload-images.jianshu.io/upload_images/3994917-6f7c4540d9a3b925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/622" alt=""></p>
<pre><code>Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;String&gt;() {
                    @Override
                    public void accept(@NonNull String s) throws Exception {
                        mRxOperatorsText.append(&quot;accept : onNext : &quot; + s + &quot;\n&quot;);
                        Log.e(TAG,&quot;accept : onNext : &quot; + s + &quot;\n&quot; );
                    }
                });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-703a9c26b2939314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>###<a href="http://reactivex.io/documentation/operators/buffer.html" target="_blank" rel="noopener">buffer</a></p>
<blockquote>
<p>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time<br>buffer </p>
</blockquote>
<blockquote>
<p>操作符接受两个参数，buffer(count,skip)，作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个  Observable 。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-538728358e88a405.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/616" alt=""></p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
                .buffer(3, 2)
                .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() {
                    @Override
                    public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception {
                        mRxOperatorsText.append(&quot;buffer size : &quot; + integers.size() + &quot;\n&quot;);
                        Log.e(TAG, &quot;buffer size : &quot; + integers.size() + &quot;\n&quot;);
                        mRxOperatorsText.append(&quot;buffer value : &quot;);
                        Log.e(TAG, &quot;buffer value : &quot; );
                        for (Integer i : integers) {
                            mRxOperatorsText.append(i + &quot;&quot;);
                            Log.e(TAG, i + &quot;&quot;);
                        }
                        mRxOperatorsText.append(&quot;\n&quot;);
                        Log.e(TAG, &quot;\n&quot;);
                    }
                });
</code></pre><p>结果：<br>    <img src="https://upload-images.jianshu.io/upload_images/3994917-08cdefce3e1e21ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>###<a href="http://reactivex.io/documentation/operators/timer.html" target="_blank" rel="noopener">timer</a></p>
<blockquote>
</blockquote>
<p>create an Observable that emits a particular item after a given delay</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-f29b7d6492d9f3f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625" alt=""></p>
<pre><code>Log.e(TAG, &quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;);
Observable.timer(2, TimeUnit.SECONDS)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程
        .subscribe(new Consumer&lt;Long&gt;() {
            @Override
            public void accept(@NonNull Long aLong) throws Exception {
                Log.e(TAG, &quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;);
            }
        });
</code></pre><p>输出：<br><img src="https://upload-images.jianshu.io/upload_images/3994917-77142cde60af8afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="noopener">Interval</a></p>
<blockquote>
</blockquote>
<p>create an Observable that emits a sequence of integers spaced by a given time interval</p>
<pre><code>Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;);
Observable.interval(3,2, TimeUnit.SECONDS)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程
        .subscribe(new Consumer&lt;Long&gt;() {
            @Override
            public void accept(@NonNull Long aLong) throws Exception {
                mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;);
                Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;);
            }
        });
</code></pre><p>输出：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-908382027a946ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/skip.html" target="_blank" rel="noopener">skip</a></p>
<blockquote>
</blockquote>
<p>suppress the first n items emitted by an Observable</p>
<blockquote>
</blockquote>
<p>代表跳过 count 个数目开始接收。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-27a77f4818941f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/621" alt=""></p>
<pre><code>Observable.just(1,2,3,4,5)
                .skip(2)
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        mRxOperatorsText.append(&quot;skip : &quot;+integer + &quot;\n&quot;);
                        Log.e(TAG, &quot;skip : &quot;+integer + &quot;\n&quot;);
                    }
                });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-58b4338ddc42fc65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/take.html" target="_blank" rel="noopener">take</a></p>
<blockquote>
</blockquote>
<p>emit only the first n items emitted by an Observable</p>
<blockquote>
</blockquote>
<p>接受一个 long 型参数 count ，代表至多接收 count 个数据</p>
<pre><code>Flowable.fromArray(1,2,3,4,5)
                .take(2)
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        mRxOperatorsText.append(&quot;take : &quot;+integer + &quot;\n&quot;);
                        Log.e(TAG, &quot;accept: take : &quot;+integer + &quot;\n&quot; );
                    }
                });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-cae2b5d836d9d181.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/debounce.html" target="_blank" rel="noopener">Debounce</a></p>
<blockquote>
<p>only emit an item from an Observable if a particular timespan has passed without it emitting another item</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-5409a530ac0e76b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/618" alt=""></p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                // send events with simulated time wait
                emitter.onNext(1); // skip
                Thread.sleep(400);
                emitter.onNext(2); // deliver
                Thread.sleep(505);
                emitter.onNext(3); // skip
                Thread.sleep(100);
                emitter.onNext(4); // deliver
                Thread.sleep(605);
                emitter.onNext(5); // deliver
                Thread.sleep(510);
                emitter.onComplete();
            }
        }).debounce(500, TimeUnit.MILLISECONDS)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        mRxOperatorsText.append(&quot;debounce :&quot; + integer + &quot;\n&quot;);
                        Log.e(TAG,&quot;debounce :&quot; + integer + &quot;\n&quot;);
                    }
                });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-3c188c501ed07d59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/last.html" target="_blank" rel="noopener">last</a></p>
<blockquote>
</blockquote>
<p>emit only the last item (or the last item that meets some condition) emitted by an Observable</p>
<blockquote>
<p>last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-616bed35cca2755e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630" alt=""></p>
<pre><code>Observable.just(1, 2, 3)
                .last(4)
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        mRxOperatorsText.append(&quot;last : &quot; + integer + &quot;\n&quot;);
                        Log.e(TAG, &quot;last : &quot; + integer + &quot;\n&quot;);
                    }
                });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-d52cc90b0843b1d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/merge.html" target="_blank" rel="noopener">merge</a></p>
<blockquote>
</blockquote>
<p>combine multiple Observables into one by merging their emissions</p>
<blockquote>
</blockquote>
<p>merge 顾名思义，熟悉版本控制工具的你一定不会不知道 merge 命令，而在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-f2e0746a6e31aee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt=""></p>
<pre><code>Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5))
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        mRxOperatorsText.append(&quot;merge :&quot; + integer + &quot;\n&quot;);
                        Log.e(TAG, &quot;accept: merge :&quot; + integer + &quot;\n&quot; );
                    }
                });
</code></pre><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/3994917-8bc6e4686d8d5701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="">reduce</a></p>
<blockquote>
</blockquote>
<p>reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-d96ac93444a78c40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/617" alt=""></p>
<pre><code>Observable.just(1, 2, 3)
               .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {
                   @Override
                   public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception {
                       return integer + integer2;
                   }
               }).subscribe(new Consumer&lt;Integer&gt;() {
           @Override
           public void accept(@NonNull Integer integer) throws Exception {
               mRxOperatorsText.append(&quot;reduce : &quot; + integer + &quot;\n&quot;);
               Log.e(TAG, &quot;accept: reduce : &quot; + integer + &quot;\n&quot;);
           }
       });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-0e76ccc3b95b6eee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="noopener">scan</a></p>
<blockquote>
</blockquote>
<p>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</p>
<blockquote>
</blockquote>
<p>scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。</p>
<pre><code>Observable.just(1, 2, 3)
                .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {
                    @Override
                    public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception {
                        return integer + integer2;
                    }
                }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(@NonNull Integer integer) throws Exception {
                mRxOperatorsText.append(&quot;scan &quot; + integer + &quot;\n&quot;);
                Log.e(TAG, &quot;accept: scan &quot; + integer + &quot;\n&quot;);
            }
        });
</code></pre><p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3994917-154573dd7cf2724a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="http://reactivex.io/documentation/operators/zip.html" target="_blank" rel="noopener">zip</a></p>
<blockquote>
</blockquote>
<p>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1656668-20b145835418c705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
             .baseUrl(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/&quot;)
             .addConverterFactory(GsonConverterFactory.create())
             .addCallAdapterFactory(RxJava2CallAdapterFactory.create()).build();

     LolInterface lolInterfaceRequest = retrofit.create(LolInterface.class);

     Observable&lt;LolDataList&gt; observable1 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io());

     Observable&lt;LolDataList&gt; observable2 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io());


     Observable.zip(observable1, observable2, new BiFunction&lt;LolDataList, LolDataList, String&gt;() {
         @Override
         public String apply(@NonNull LolDataList lolDataList, @NonNull LolDataList lolDataList2) throws Exception {
             return &quot;合并后的数据为 lolDataList1=&quot;+lolDataList.getData().get(0).getDisplayName() + &quot;,lolDataList2=&quot;+lolDataList2.getData().get(0).getDisplayName();
         }
     }).subscribeOn(Schedulers.io())
             .observeOn(AndroidSchedulers.mainThread())
             .subscribe(new Consumer&lt;String&gt;() {
                 @Override
                 public void accept(@NonNull String s) throws Exception {
                     Log.e(TAG, &quot;accept: 成功：&quot; + s+&quot;\n&quot;);
                 }
             }, new Consumer&lt;Throwable&gt;() {
                 @Override
                 public void accept(@NonNull Throwable throwable) throws Exception {
                     Log.e(TAG, &quot;accept: 失败：&quot; + throwable+&quot;\n&quot;);
                 }
             });
</code></pre><p>结果：</p>
<blockquote>
</blockquote>
<p>accept: 成功：合并后的数据为 lolDataList1=灭世魔神 诺提勒斯,lolDataList2=灭世魔神 诺提勒斯</p>
<p>####subScribeOn</p>
<blockquote>
<p>指定的就是发射事件的线程</p>
</blockquote>
<p>多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略</p>
<p>####observeOn</p>
<blockquote>
</blockquote>
<p>指定的就是订阅者接收事件的线程。</p>
<blockquote>
<p>多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次</p>
</blockquote>
<p>####线程切换</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
         @Override
         public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {
             Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());
             e.onNext(1);
             e.onComplete();
         }
     }).subscribeOn(Schedulers.newThread())
             .subscribeOn(Schedulers.io())
             .observeOn(AndroidSchedulers.mainThread())
             .doOnNext(new Consumer&lt;Integer&gt;() {
                 @Override
                 public void accept(@NonNull Integer integer) throws Exception {
                     Log.e(TAG, &quot;After observeOn(mainThread)，Current thread is &quot; + Thread.currentThread().getName());
                 }
             })
             .observeOn(Schedulers.io())
             .subscribe(new Consumer&lt;Integer&gt;() {
                 @Override
                 public void accept(@NonNull Integer integer) throws Exception {
                     Log.e(TAG, &quot;After observeOn(io)，Current thread is &quot; + Thread.currentThread().getName());
                 }
             });
</code></pre><p>结果：</p>
<pre><code>07-14 11:43:11.669 8550-8611/com.nanchen.rxjava2examples E/RxThreadActivity: Observable thread is : RxNewThreadScheduler-1
07-14 11:43:11.670 8550-8550/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(mainThread)，Current thread is main
07-14 11:43:11.671 8550-8612/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(io)，Current thread is RxCachedThreadScheduler-2
</code></pre><p>####场景举例</p>
<blockquote>
</blockquote>
<p>一个简单的网络请求</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Response&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Response&gt; e) throws Exception {
                Builder builder = new Builder()
                        .url(&quot;http://api.avatardata.cn/MobilePlace/LookUp?key=ec47b85086be4dc8b5d941f5abd37a4e&amp;mobileNumber=13021671512&quot;)
                        .get();
                Request request = builder.build();
                Call call = new OkHttpClient().newCall(request);
                Response response = call.execute();
                e.onNext(response);
                Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
            }
        }).map(new Function&lt;Response, MobileAddress&gt;() {
                    @Override
                    public MobileAddress apply(@NonNull Response response) throws Exception {

                        Log.e(TAG, &quot;map 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
                        if (response.isSuccessful()) {
                            ResponseBody body = response.body();
                            if (body != null) {
                                Log.e(TAG, &quot;map:转换前:&quot; + response.body());
                                return new Gson().fromJson(body.string(), MobileAddress.class);
                            }
                        }
                        return null;
                    }
                }).observeOn(AndroidSchedulers.mainThread())
                .doOnNext(new Consumer&lt;MobileAddress&gt;() {
                    @Override
                    public void accept(@NonNull MobileAddress s) throws Exception {
                        Log.e(TAG, &quot;doOnNext 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
                        Log.e(TAG, &quot;doOnNext: 保存成功：&quot; + s.toString() + &quot;\n&quot;);

                    }
                }).subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;MobileAddress&gt;() {
                    @Override
                    public void accept(@NonNull MobileAddress data) throws Exception {
                        Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
                        Log.e(TAG, &quot;成功:&quot; + data.toString() + &quot;\n&quot;);
                    }
                }, new Consumer&lt;Throwable&gt;() {
                    @Override
                    public void accept(@NonNull Throwable throwable) throws Exception {
                        Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
                        Log.e(TAG, &quot;失败：&quot; + throwable.getMessage() + &quot;\n&quot;);
                    }
                });
</code></pre><p>执行结果：</p>
<pre><code>07-13 09:13:08.664 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: map 线程:RxCachedThreadScheduler-1
    map:转换前:okhttp3.internal.http.RealResponseBody@3e17a0f
07-13 09:13:08.691 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: create 线程:RxCachedThreadScheduler-1
07-13 09:13:08.691 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext 线程:main
07-13 09:13:08.702 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext: 保存成功：MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null}
07-13 09:13:08.737 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: subscribe 线程:main
07-13 09:13:08.741 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: 成功:MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null}
</code></pre><p>####多个网络请求串行执行</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;LolDataList&gt;() {
           @Override
           public void subscribe(ObservableEmitter&lt;LolDataList&gt; e) throws Exception {
               Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
               Request.Builder builder = new Request.Builder()
                       .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;)
                       .get();
               Request request = builder.build();
               Call call = new OkHttpClient().newCall(request);
               okhttp3.Response response = call.execute();
               if (response.isSuccessful()) {
                   ResponseBody body = response.body();
                   if (body != null) {
                       LolDataList dataList =  new Gson().fromJson(body.string(), LolDataList.class);
                       e.onNext(dataList);
                   }
               }

           }
       }).subscribeOn(Schedulers.io())
       .doOnNext(new Consumer&lt;LolDataList&gt;() {
           @Override
           public void accept(LolDataList lolDataList) throws Exception {
               // 处理数据保存逻辑
           }
       })
       .flatMap(new Function&lt;LolDataList, ObservableSource&lt;LolDataList&gt;&gt;() {
           @Override
           public ObservableSource&lt;LolDataList&gt; apply(LolDataList lolDataList) throws Exception {
               Request.Builder builder = new Request.Builder()
                       .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;)
                       .get();
               Request request = builder.build();
               Call call = new OkHttpClient().newCall(request);
               okhttp3.Response response = call.execute();
               LolDataList dataList = null;
               if (response.isSuccessful()) {
                   ResponseBody body = response.body();
                   if (body != null) {
                        dataList =  new Gson().fromJson(body.string(), LolDataList.class);
                   }
               }
               Log.e(TAG, &quot;flatMap 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;);
               return Observable.just(dataList);
           }
       })
       .observeOn(AndroidSchedulers.mainThread())
       .subscribe(new Consumer&lt;LolDataList&gt;() {
           @Override
           public void accept(LolDataList lolDataList) throws Exception {
               Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;+lolDataList.getData().size());

           }
       }, new Consumer&lt;Throwable&gt;() {
           @Override
           public void accept(Throwable throwable) throws Exception {

           }
       });
</code></pre><p>执行结果：</p>
<pre><code>13 16:48:53.667 9180-9382/? E/RxCaseFlatMapActivity: create 线程:RxCachedThreadScheduler-2
07-13 16:48:54.104 9180-9382/? E/RxCaseFlatMapActivity: flatMap 线程:RxCachedThreadScheduler-2
07-13 16:48:54.105 9180-9180/? E/RxCaseFlatMapActivity: subscribe 线程:main6
</code></pre><p>####间隔任务实现心跳</p>
<pre><code>mDisposable = Flowable.interval(1, TimeUnit.SECONDS)
              .doOnNext(new Consumer&lt;Long&gt;() {
                  @Override
                  public void accept(@NonNull Long aLong) throws Exception {
                      Log.e(TAG, &quot;accept: doOnNext : &quot;+aLong );
                  }
              })
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe(new Consumer&lt;Long&gt;() {
                  @Override
                  public void accept(@NonNull Long aLong) throws Exception {
                      Log.e(TAG, &quot;accept: 设置文本 ：&quot;+aLong );
                      mRxOperatorsText.append(&quot;accept: 设置文本 ：&quot;+aLong +&quot;\n&quot;);
                  }
              });
</code></pre><p>结果：</p>
<pre><code>07-14 11:01:19.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 0
07-14 11:01:19.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：0
07-14 11:01:20.048 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 1
07-14 11:01:20.050 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：1
07-14 11:01:21.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 2
07-14 11:01:21.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：2
07-14 11:01:22.049 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 3
07-14 11:01:22.051 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：3
</code></pre><p>###资源链接</p>
<p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Single.html" target="_blank" rel="noopener">RxJava文档中文版</a></p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2016/12/09/Tinker-接入/" class="next-post btn btn-default" title='Tinker 热补丁接入过程中的坑！！！'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Tinker 热补丁接入过程中的坑！！！</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>






                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <p>暂无目录</p>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



	<script src="/js/search.js?rev=@@hash"></script>


<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>