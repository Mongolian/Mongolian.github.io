{"meta":{"title":"lee","subtitle":null,"description":"记录学习，生活中的点点滴滴...","author":"lee","url":"http://yoursite.com"},"pages":[{"title":"Handler结构模型","date":"2018-07-16T11:09:19.000Z","updated":"2018-07-16T11:11:43.000Z","comments":true,"path":"Handler结构模型/index.html","permalink":"http://yoursite.com/Handler结构模型/index.html","excerpt":"","text":"测试哈哈"},{"title":"categories","date":"2018-07-18T14:51:45.000Z","updated":"2018-07-18T14:51:59.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-18T14:42:35.000Z","updated":"2018-07-18T14:43:27.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Tinker 热补丁接入","slug":"Tinker-集成","date":"2018-07-19T13:36:10.000Z","updated":"2018-07-19T13:56:05.000Z","comments":true,"path":"2018/07/19/Tinker-集成/","link":"","permalink":"http://yoursite.com/2018/07/19/Tinker-集成/","excerpt":"","text":"Tinker 热补丁接入过程中的坑！！！##Tinker 介绍官方接入说明 ##gradle 接入gradle是推荐的接入方式，在gradle插件tinker-patch-gradle-plugin中我们帮你完成proguard、multiDex以及Manifest处理等工作。 ##添加gradle依赖在项目的根目录build.gradle中，添加tinker-patch-gradle-plugin的依赖 引入tinker 核心库然后在baseUI-lib文件的build.gradle，我们需要添加tinker的库依赖以及apply tinker的gradle插件. 在APP/build.gradle 下面添加tinker 的配置文件 keep_in_main_dex.txt 文件内容就是指定你要放置到主DEX 中的类 -keep public class implements com.tencent.tinker.loader.app.ApplicationLifeCycle { ;} -keep public class extends com.tencent.tinker.loader.TinkerLoader { ;} -keep public class extends com.tencent.tinker.loader.app.TinkerApplication { } -keep class com.tencent.tinker.loader.* { ;} -keep class com.anzogame.corelib.GameApplication { *;} 加入tinker EXT提供配置文件 tinkerEnabled: tinker 的开关tinkerOldApkPath : 生补丁包的基础apk，线上包版本tinkerApplyMappingPath : 线上包混淆文件生成mapping 文件tinkerApplyResourcePath : 线上包的资源id 文件以上版本是我们每一个正式版本需要保留的生成热补丁的基础信息tinkerBuildFlavorDirectory : 多渠道用到，我们不用，下面说到我们怎么处理多渠道打包 ###加入 TinkerPatch 配置 if (buildWithTinker()) { apply plugin: 'com.tencent.tinker.patch' tinkerPatch { /** * necessary，default 'null' * the old apk path, use to diff with the new apk to build * add apk from the build/bakApk */ oldApk = getOldApkPath() /** * optional，default 'false' * there are some cases we may get some warnings * if ignoreWarning is true, we would just assert the patch process * case 1: minSdkVersion is below 14, but you are using dexMode with raw. * it must be crash when load. * case 2: newly added Android Component in AndroidManifest.xml, * it must be crash when load. * case 3: loader classes in dex.loader{} are not keep in the main dex, * it must be let tinker not work. * case 4: loader classes in dex.loader{} changes, * loader classes is ues to load patch dex. it is useless to change them. * it won't crash, but these changes can't effect. you may ignore it * case 5: resources.arsc has changed, but we don't use applyResourceMapping to build */ ignoreWarning = false /** * optional，default 'true' * whether sign the patch file * if not, you must do yourself. otherwise it can't check success during the patch loading * we will use the sign config with your build type */ useSign = true /** * Warning, applyMapping will affect the normal android build! */ buildConfig { /** * optional，default 'null' * if we use tinkerPatch to build the patch apk, you'd better to apply the old * apk mapping file if minifyEnabled is enable! * Warning: * you must be careful that it will affect the normal assemble build! */ applyMapping = getApplyMappingPath() /** * optional，default 'null' * It is nice to keep the resource id from R.txt file to reduce java changes */ applyResourceMapping = getApplyResourceMappingPath() /** * necessary，default 'null' * because we don't want to check the base apk with md5 in the runtime(it is slow) * tinkerId is use to identify the unique base apk when the patch is tried to apply. * we can use git rev, svn rev or simply versionCode. * we will gen the tinkerId in your manifest automatic */ tinkerId = \"1.2\" } dex { /** * optional，default 'jar' * only can be 'raw' or 'jar'. for raw, we would keep its original format * for jar, we would repack dexes with zip format. * if you want to support below 14, you must use jar * or you want to save rom or check quicker, you can use raw mode also */ dexMode = \"jar\" /** * optional，default 'false' * if usePreGeneratedPatchDex is true, tinker framework will generate auxiliary class * and insert auxiliary instruction when compiling base package using * assemble{Debug/Release} task to prevent class pre-verified issue in dvm. * Besides, a real dex file contains necessary class will be generated and packed into * patch package instead of any patch info files. * * Use this mode if you have to use any dex encryption solutions. * * Notice: If you change this value, please trigger clean task * and regenerate base package. */ usePreGeneratedPatchDex = false /** * necessary，default '[]' * what dexes in apk are expected to deal with tinkerPatch * it support * or ? pattern. */ pattern = [\"classes*.dex\", \"assets/secondary-dex-?.jar\"] /** * necessary，default '[]' * Warning, it is very very important, loader classes can't change with patch. * thus, they will be removed from patch dexes. * you must put the following class into main dex. * Simply, you should add your own application {@code tinker.sample.android.SampleApplication} * own tinkerLoader, and the classes you use in them * */ loader = [\"com.tencent.tinker.loader.*\", //warning, you must change it with your application \"com.anzogame.corelib.GameApplication\", \"com.anzogame.corelib.BuildConfig.BaseBuildInfo\" ] } lib { /** * optional，default '[]' * what library in apk are expected to deal with tinkerPatch * it support * or ? pattern. * for library in assets, we would just recover them in the patch directory * you can get them in TinkerLoadResult with Tinker */ pattern = [\"lib/armeabi/*.so\"] } res { /** * optional，default '[]' * what resource in apk are expected to deal with tinkerPatch * it support * or ? pattern. * you must include all your resources in apk here, * otherwise, they won't repack in the new apk resources. */ pattern = [\"res/*\", \"assets/*\", \"resources.arsc\", \"AndroidManifest.xml\"] /** * optional，default '[]' * the resource file exclude patterns, ignore add, delete or modify resource change * it support * or ? pattern. * Warning, we can only use for files no relative with resources.arsc */ // ignoreChange = [\"*.png\"] ignoreChange = [\"assets/sample_meta.txt\"] /** * default 100kb * for modify resource, if it is larger than 'largeModSize' * we would like to use bsdiff algorithm to reduce patch file size */ largeModSize = 100 } packageConfig { /** * optional，default 'TINKER_ID, TINKER_ID_VALUE' 'NEW_TINKER_ID, NEW_TINKER_ID_VALUE' * package meta file gen. path is assets/package_meta.txt in patch file * you can use securityCheck.getPackageProperties() in your ownPackageCheck method * or TinkerLoadResult.getPackageConfigByName * we will get the TINKER_ID from the old apk manifest for you automatic, * other config files (such as patchMessage below)is not necessary */ configField(\"patchMessage\", \"tinker is sample to use\") /** * just a sample case, you can use such as sdkVersion, brand, channel... * you can parse it in the SamplePatchListener. * Then you can use patch conditional! */ configField(\"platform\", \"all\") /** * patch version via packageConfig */ configField(\"patchVersion\", \"1.0\") } //or you can add config filed outside, or get meta value from old apk //project.tinkerPatch.packageConfig.configField(\"test1\", project.tinkerPatch.packageConfig.getMetaDataFromOldApk(\"Test\")) //project.tinkerPatch.packageConfig.configField(\"test2\", \"sample\") /** * if you don't use zipArtifact or path, we just use 7za to try */ sevenZip { /** * optional，default '7za' * the 7zip artifact path, it will use the right 7za with your platform */ zipArtifact = \"com.tencent.mm:SevenZip:1.1.10\" /** * optional，default '7za' * you can specify the 7za path yourself, it will overwrite the zipArtifact value */ // path = \"/usr/local/bin/7za\" } } List flavors = new ArrayList(); project.android.productFlavors.each { flavor -> flavors.add(flavor.name) } boolean hasFlavors = flavors.size() > 0 /** * bak apk and mapping */ android.applicationVariants.all { variant -> /** * task type, you want to bak */ def taskName = variant.name def date = new Date().format(\"MMdd-HH-mm-ss\") tasks.all { if (\"assemble${taskName.capitalize()}\".equalsIgnoreCase(it.name)) { it.doLast { copy { def fileNamePrefix = \"${project.name}-${variant.baseName}\" def newFileNamePrefix = hasFlavors ? \"${fileNamePrefix}\" : \"${fileNamePrefix}-${date}\" def destPath = hasFlavors ? file(\"${bakPath}/${project.name}-${date}/${variant.flavorName}\") : bakPath from variant.outputs.outputFile into destPath rename { String fileName -> fileName.replace(\"${fileNamePrefix}.apk\", \"${newFileNamePrefix}.apk\") } from \"${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt\" into destPath rename { String fileName -> fileName.replace(\"mapping.txt\", \"${newFileNamePrefix}-mapping.txt\") } from \"${buildDir}/intermediates/symbols/${variant.dirName}/R.txt\" into destPath rename { String fileName -> fileName.replace(\"R.txt\", \"${newFileNamePrefix}-R.txt\") } } } } } } project.afterEvaluate { //sample use for build all flavor for one time if (hasFlavors) { task(tinkerPatchAllFlavorRelease) { group = 'tinker' def originOldPath = getTinkerBuildFlavorDirectory() for (String flavor : flavors) { def tinkerTask = tasks.getByName(\"tinkerPatch${flavor.capitalize()}Release\") dependsOn tinkerTask def preAssembleTask = tasks.getByName(\"process${flavor.capitalize()}ReleaseManifest\") preAssembleTask.doFirst { String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15) project.tinkerPatch.oldApk = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk\" project.tinkerPatch.buildConfig.applyMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt\" project.tinkerPatch.buildConfig.applyResourceMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt\" } } } task(tinkerPatchAllFlavorDebug) { group = 'tinker' def originOldPath = getTinkerBuildFlavorDirectory() for (String flavor : flavors) { def tinkerTask = tasks.getByName(\"tinkerPatch${flavor.capitalize()}Debug\") dependsOn tinkerTask def preAssembleTask = tasks.getByName(\"process${flavor.capitalize()}DebugManifest\") preAssembleTask.doFirst { String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13) project.tinkerPatch.oldApk = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk\" project.tinkerPatch.buildConfig.applyMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt\" project.tinkerPatch.buildConfig.applyResourceMapping = \"${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt\" } } } } } } 详细参数参看文档 [传送门](https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97) 配置就到这里，然后执行assembleDebug，安装apk，千万不要 RUN ，RUN方式生成是补丁打补丁的，编译不通过 彩蛋....(Too many classes in --main-dex-list, main dex capacity exceeded) ![](http://upload-images.jianshu.io/upload_images/1656668-45e6c6c1e6bef715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 为什么会这样子呢 ？ 我们已经采用了GOOGLE 的方案多DEX ,从报错上来看应该是主DEX 的类太多了，超过了限制，但是这个哪些类放到主DEX 不是我们决定的啊，很操蛋， 那么我们来看系统是如何分包的. ####在项目中，可以直接运行 gradle 的 task 。 - **collect{flavor}{buildType}MultiDexComponents Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 文件中去。** - **packageAll{flavor}DebugClassesForMultiDex Task 。该 task 是将所有类打包成 jar 文件存在 build/intermediates/multi-dex/{flavor}/debug/allclasses.jar 。 当 BuildType 为 Release 的时候，执行的是 proguard{flavor}Release Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 build/intermediates/classes-proguard/{flavor}/release/classes.jar** - **shrink{flavor}{buildType}MultiDexComponents Task 。该 task 会根据 maindexlist.txt 生成 componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 build/intermediates/multi-dex/{flavor}/{buildType}/componentClasses.jar** - **create{flavor}{buildType}MainDexClassList Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。** 通过上面的流程我们可以得出 ，我们主DEX 中的类取决于build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中的内容 ，那么我们在执行MultiDexComponents task 时候做些拦截，把Activity 从主DEX中移除，这里面的移除不是全部移除，如果Activity中包含有子类，那么我们的移除是无效，还是会被放入到主DEX,另外，如果你 Application 、Service 、 Receiver 、 Provider 中的直接引用类还是会被放到第一个主DEX中。 ![](http://upload-images.jianshu.io/upload_images/1656668-277fc58819134e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 当我们采用多DEX 的时候，应用启动的首先回加载主DEX ，其他的 dex 需要我们在应用启动后进行动态加载安装， 通过MultiDex.install(getApplication());加载其他DEX. 这样的方法虽然可行，我们把 很多 Activity 放到其他的DEX 中了 ，可是生成包发现DEX 还是有9.2M 这种方式如果随着代码增加还是有可能导致主DEX 超限的问题，这时候我们可以采用dexnkife 通过配置形式把Application 中相关的类和一些必要的首页类放置到主DEX 中，可以准确控制哪些放入到主DEX,这样也可以解决问题。 那么Google 官方Multidex是如何加载的呢？ Google 官方支持 Multidex 的 jar 包是 android-support-multidex.jar，该 jar 包从 build tools 21.1 开始支持。这个 jar 加载 apk 中的从 dex 流程如下： ![](https://segmentfault.com/image?src=http://i.imgur.com/QAcLV9f.jpg&objectId=1190000004053072&token=a1263cbb792a37bbc4f391b8725d4bc4) 此处主要的工作就是从 apk 中提取出所有的从 dex（classes2.dex，classes3.dex，…），然后通过反射依次安装加载从 dex 并合并 DexPathList 的 Element 数组。 ##为什么API 21 以上就没有主DEX 过大的问题呢？ - **这是为了5.0以上系统在安装过程中的art阶段就将所有的classes(..N).dex合并到一个单独的oat文件(5.0以下只能苦逼的启动时加载 对于Art相关知识，可以参考老罗的系列文章 [传送门](http://blog.csdn.net/luoshengyang/article/details/39307813)** ###DEX类分包的规则 我们开启多DEX支持一般是指定了multiDexEnabled，系统其实它利用的是Android sdk build tool中的mainDexClasses脚本，这在版本21以上才会有。使用方法非常很简单： mainDexClasses [--output ] 该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步： a. 环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。 b. 使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。 c. 通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表。 ![](http://upload-images.jianshu.io/upload_images/1656668-54771519c5464a75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 这里只是简单的得到所有入口类(即rules中的Instrumentation、application、Activity、Annotation等等)的直接引入类。何为直接引用类？在init过程，会在校验阶段去resolve它各个方法、变量引用到的类，这些类统称为某个类的直接引用类。举个栗子： public class MainActivity extends Activity { protected void onCreate(Bundle savedInstanceState) { DirectReferenceClass test = new DirectReferenceClass(); } } public class DirectReferenceClass { public DirectReferenceClass() { InDirectReferenceClass test = new InDirectReferenceClass(); } } public class InDirectReferenceClass { public InDirectReferenceClass() { } } 上面有MainActivity、DirectReferenceClass、InDirectReferenceClass三个类，其中DirectReferenceClass是MainActivity的直接引用类，InDirectReferenceClass是DirectReferenceClass的直接引用类。而InDirectReferenceClass是MainActivity的间接引用类(即直接引用类的所有直接引用类)。 对于5.0以下的系统，我们需要在启动时手动加载其他的dex。而我们并没有要求得到所有的间接引用类，这是因为我们在attachBaseContext的时候，已将其他dex加载。 事实上，若我们在attachBaseContext中调用Multidex.install，我们只需引入Application的直接引用类即可，mainDexClasses将Activity、ContentProvider、Service等的直接引用类也引入，主要是满足需要在非attachBaseContent加载多dex的需求。另一方面，若存在以下代码，将出现NoClassDefFoundError错误。 public class HelloMultiDexApplication extends Application { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); DirectReferenceClass test = new DirectReferenceClass(); MultiDex.install(this); } } 这是因为在实际运行过程中，DirectReferenceClass需要的InDirectReferenceClass并不一定在主dex。解决方法是手动将该类放于dx的-main-dex-list参数中： afterEvaluate { tasks.matching { it.name.startsWith('dex') }.each { dx -> if (dx.additionalParameters == null) { dx.additionalParameters = [] } dx.additionalParameters += '--multi-dex' dx.additionalParameters += \"--main-dex-list=$projectDir/\".toString() } } ##LinearAlloc 是什么 LinearAlloc 主要用来管理 Dalvik 中 class 加载时的内存，就是让 App 在执行时减少系统内存的占用。在 App 的安装过程中，系统会运行一个名为 dexopt 的程序为该应用在当前机型中运行做准备。dexopt 使用 LinearAlloc 来存储应用的方法信息。App 在执行前会将 class 读进 LinearAlloc 这个 buffer 中，这个 LinearAlloc 在 Android 2.3 之前是 4M 或 5M ，到 4.0 之后变为 8M 或 16M。因为 5M 实在是太小了，可能还没有 65536 就已经超过 5M 了，什么意思呢，就是只有一个包的情况下也有可能出现 INSTALL_FAILED_DEXOPT ，原因就在于 LinearAlloc。 ###解决 LinearAlloc DEXOPT &amp;&amp; DEX2OAT 是什么？ ###dexopt当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 apk路径 @ apk名 @ classes.dex 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。 更多可查看 Dalvik Optimization and Verification With dexopt 。 ####dex2oatAndroid Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。 更多可查看 Android运行时ART简要介绍和学习计划 。 ##Application Not Responding 因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 MultiDex.install() 操作是在 Application.attachBaseContext() 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 MultiDex.install() 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那又会 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。 ###微信/手Q加载方案对于微信来说，我们一共有111052个方法。以线性内存3355444(限制5m,给系统预留部分)、方法数64K为限制，即当满足任意一个条件时，将拆分dex。由此微信将得到一个主dex,两个子dex，若微信采用Android方案，在首次启动时将长期无响应(没有出现黑屏时因为默认皮肤的原因)，这对处女座的我来说是无法接受的。应该如何去做？微信与手Q的方案是类似的，将首次加载放于地球中，并用线程去加载(但是5.0之前加载dex时还是会挂起主线程)。 Dex形式暂时我们还是放于assets下，以assets/secondary-program-dex-jars/secondary-N.dex.jar命名。为什么不以classes(..N).dex？这是因为一来觉得以Android的推广速度，5.0用户增长应该是遥遥无期的，二来加载Dex的代码，传进去的是zip，在加载前我们需要验证MD5，确保所加载的Dex没有被篡改(Android官方没有验证，主要是只有root才能更改吧)。 /** Makes an array of dex/resource path elements, one per element of the given array.*/private static Element[] makeDexElements(ArrayList files, File optimizedDirectory,ArrayList&lt;IOException&gt; suppressedExceptions) { 事实上，应该传进去的是dex也是应该可以的，这块在下一个版本将采用classes(..N).dex。但是如果我们使用了线程加载，并且弹出提示界面，对用户来说并不是无法接受。 Dex类分包的规则分包规则即将所有Application、ContentProvider以及所有export的Activity、Service、Receiver的间接依赖集都必须放在主dex。对于微信现在来说，这部分大约有41306个方法，每次通过扫描AndroidMifest计算耗时大约为20s不到。怎么计算？可以参考buck或者mainDexClasses的做法。 public MainDexListBuilder(String rootJar, String pathString) throws IOException { path = new Path(pathString); ClassReferenceListBuilder mainListBuilder=new ClassReferenceListBuilder(path);加载Dex的方式加载逻辑这边主要判断是否已经dexopt，若已经dexopt，即放在attachBaseContext加载，反之放于地球中用线程加载。怎么判断？其实很低级，因为在微信中，若判断revision改变，即将dex以及dexopt目录清空。只需简单判断两个目录dex名称、数量是否与配置文件的一致。 (name md5 校验是否加载成功类)secondary-1.dex.jar 63e5240eac9bdb5101fc35bd40a98679 secondary.dex01.Canarysecondary-2.dex.jar e7d2a4a181f579784a4286193feaf457 secondary.dex02.Canary总的来说，这种方案用户体验较好，缺点在于太过复杂，每次都需重新扫描依赖集，而且使用的是比较大的间接依赖集(要真正运行到，直接依赖集是不行的)。当前微信必要的依赖集已经41306个方法，说不定哪一天就爆了。 ###FaceBook加载方案 那是否存在一种加载方式它的依赖集很小，但却不会像官方方案一样造成明显的卡顿？逆过不少app,发现facebook的思路还是挺不错的，下面作一个简单的说明： Dex形式微信与facebook的dex形式是完全一致的，这是因为我们也是使用facebook开源工具buck编译的。但是我们做了一个自动生成buck脚本的工作，即开发人员无须关心buck脚本如何编写。 Dex类分包的规则facebook将加载Dex的逻辑放于单独的nodex进程，这是一个非常简单、轻量级的进程。它没有任何的ContentProvider，只有有限的几个Activity、Service。 所以依赖集为Application、NodexSplashActivity的间接依赖集即可，而且这部分逻辑应该相对稳定，我们无须做动态扫描。这就实现了一个非常轻量级的依赖集方案。 加载Dex的方式加载dex逻辑也非常简单，由于NodexSplashActivity的intent-filter指定为Main与LAUNCHER。首先拉起nodex进程，然后初始化NodexSplashActivityActivity，若此时Dex已经初始化过，即直接跳转到主页面。 这种方式好处在于依赖集非常简单，同时首次加载Dex时也不会卡死。但是它的缺点也很明显，即每次启动主进程时，都需先启动nodex进程。尽管nodex进程逻辑非常简单，这也需100ms以上。若微信对启动时间非常敏感，很难会去采用这个方案。 ###美团加载方案传送门 在 gradle 生成 dex 文件的这步中，自定义一个 task 来干预 dex 的生产过程，从而产生多个 dex 。 tasks.whenTaskAdded { task -&gt; if (task.name.startsWith(‘proguard’) &amp;&amp; (task.name.endsWith(‘Debug’) || task.name.endsWith(‘Release’))) { task.doLast { makeDexFileAfterProguardJar(); } task.doFirst { delete “${project.buildDir}/intermediates/classes-proguard”; String flavor = task.name.substring(&apos;proguard&apos;.length(), task.name.lastIndexOf(task.name.endsWith(&apos;Debug&apos;) ? &quot;Debug&quot; : &quot;Release&quot;)); generateMainIndexKeepList(flavor.toLowerCase()); } } else if (task.name.startsWith(&apos;zipalign&apos;) &amp;&amp; (task.name.endsWith(&apos;Debug&apos;) || task.name.endsWith(&apos;Release&apos;))) { task.doFirst { ensureMultiDexInApk(); } } } 把 Service、Receiver、Provider 涉及到的代码都放到主 dex 中，而把 Activity 涉及到的代码进行了一定的拆分，把首页 Activity、Laucher Activity 、欢迎页的 Activity 、城市列表页 Activity 等所依赖的 class 放到了主 dex 中，把二级、三级页面的 Activity 以及业务频道的代码放到了第二个 dex 中，为了减少人工分析 class 的依赖所带了的不可维护性和高风险性，美团编写了一个能够自动分析 class 依赖的脚本， 从而能够保证\u001d主 dex 包含 class 以及他们所依赖的所有 class 都在其内，这样这个脚本就会在打包之前自动分析出启动到主 dex 所涉及的所有代码，保证主 dex 运行正常。 加载 dex 的方式 通过分析 Activity 的启动过程，发现 Activity 是由 ActivityThread 通过 Instrumentation 来启动的，那么是否可以在 Instrumentation 中做一定的手脚呢？通过分析代码 ActivityThread 和 Instrumentation 发现，Instrumentation 有关 Activity 启动相关的方法大概有：execStartActivity、 newActivity 等等，这样就可以在这些方法中添加代码逻辑进行判断这个 class 是否加载了，如果加载则直接启动这个 Activity，如果没有加载完成则启动一个等待的 Activity 显示给用户，然后在这个 Activity 中等待后台第二个 dex 加载完成，完成后自动跳转到用户实际要跳转的 Activity；这样在代码充分解耦合，以及每个业务代码能够做到颗粒化的前提下，就做到第二个 dex 的按需加载了。 美团的这种方式对主 dex 的要求非常高，因为第二个 dex 是等到需要的时候再去加载。重写Instrumentation 的 execStartActivity 方法，hook 跳转 Activity 的总入口做判断，如果当前第二个 dex 还没有加载完成，就弹一个 loading Activity等待加载完成。 引入dexnkife 核心库dexnkife 项目地址: DexKnifePlugin. dexnkife 帮助我们划分类到主DEX ，使DEX 划分通过配置形式来完成 使用 # 进行注释, 当行起始加上 #, 这行配置被禁用. 全局过滤, 如果没设置 -filter-suggest 并不会应用到 建议的maindexlist.如果你想要某个包路径在maindex中，则使用 -keep 选项，即使他已经在分包的路径中.-keep android.support.v4.view.** 这条配置可以指定这个包下类在第二dex中.android.support.v?.** 使用.class后缀，代表单个类.-keep android.support.v7.app.AppCompatDialogFragment.class 不包含Android gradle 插件自动生成的miandex列表.-donot-use-suggest 将 全局过滤配置应用到 建议的maindexlist中, 但 -donot-use-suggest 要关闭.-filter-suggest 不进行dex分包， 直到 dex 的id数量超过 65536.-auto-maindex dex 扩展参数, 例如 –set-max-idx-number=50000如果出现 DexException: Too many classes in –main-dex-list, main dex capacity exceeded，则需要调大数值-dex-param –set-max-idx-number=50000 显示miandex的日志.-log-mainlist 如果你只想过滤 建议的maindexlist, 使用 -suggest-split 和 -suggest-keep.如果同时启用 -filter-suggest, 全局过滤会合并到它们中.-suggest-split .MainActivity2.class-suggest-keep android.support.multidex. ##搞定分DEX ，继续集成Tinker 生成基础版本首先执行gradle 任务中的assableRelease,release 环境下打包会输出到/home/anzogame/release/包名/版本/release/，同时会在release同级目录下生成bakApk/app-1209-15-34-25/_test/ 生成apk ,mapping ,R.txt 文件，该文件就是基础版本 生成补丁包 在build.grale 中将tinkerOldApkPath，tinkerApplyMappingPath，tinkerApplyResourcePath 替换生新生成apk，maping和R.txt 文件, 然后修改自己代码，注意要修改一行CoreApplicationLike 中的代码 ，可以加一个日志，因为1.7.5的tinker 有一个bug ，最好修改一下，然后执行 gradle 任务中的，tinkerPatchRelease 生成补丁文件,最后生成的补丁文件 ###输出文件详解 然后将生成补丁patch_signed_7zip.apk 重名 patch_signed_7zip.so 通过后台CMS 传到SERVER ,客户端安装基础版本，启动查看补丁是否安装成功。 /Tinker.DexDiffPatchInternal: success recover dex file: /data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes.dex.jar, use time: 411812-09 16:21:34.900 12198-12228/? I/Tinker.DexDiffPatchInternal: try Extracting /data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes2.dex.jar12-09 16:21:36.416 12198-12228/? I/Tinker.DexDiffPatchInternal: isExtractionSuccessful: true12-09 16:21:36.526 12198-12228/? I/Tinker.DexDiffPatchInternal: try Extracting /data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes3.dex.jar12-09 16:21:36.902 12198-12228/? I/Tinker.DexDiffPatchInternal: isExtractionSuccessful: true12-09 16:21:36.932 12198-12228/? I/Tinker.DexDiffPatchInternal: try Extracting /data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes4.dex.jar12-09 16:21:36.976 12198-12228/? I/Tinker.DexDiffPatchInternal: isExtractionSuccessful: true12-09 16:21:36.982 12198-12228/? I/Tinker.DexDiffPatchInternal: try Extracting /data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/test.dex.jar12-09 16:21:36.985 12198-12228/? I/Tinker.DexDiffPatchInternal: isExtractionSuccessful: true12-09 16:21:49.737 12198-12228/? I/Tinker.DexDiffPatchInternal: recover dex result:true, cost:19018, isUpgradePatch:true12-09 16:21:49.739 12198-12228/? W/Tinker.BsDiffPatchInternal: patch recover, library is not contained12-09 16:21:49.746 12198-12228/? I/Tinker.ResDiffPatchInternal: res dir: /data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/res/, meta: resArscMd5:91dfea65855052958dc4cd3abd408550 arscBaseCrc:2718315645 pattern:res/. pattern:resources.arsc pattern:assets/. addedSet:assets/only_use_to_test_tinker_resource.txt modifiedSet:res/layout/activity_patch.xml12-09 16:21:49.797 12198-12228/? I/Tinker.ResDiffPatchInternal: no large modify resources, just return12-09 16:21:53.353 12198-12228/? I/Tinker.ResDiffPatchInternal: final new resource file:/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/res/resources.apk, entry count:7596, size:3925938412-09 16:21:53.353 12198-12228/? I/Tinker.ResDiffPatchInternal: recover resource result:true, cost:3613, isNewPatch:true12-09 16:21:53.366 12198-12228/? W/Tinker.UpgradePatch: UpgradePatch tryPatch: done, it is ok12-09 16:21:53.366 12198-12228/? I/Tinker.DefaultPatchReporter: patchReporter: patch all result path:/storage/emulated/0/AnZoLOL/patch/patch_signed_7zip.so, success:true, cost:22752, isUpgrade:true12-09 16:21:53.367 12198-12228/? I/Tinker.PatchFileUtil: safeDeleteFile, try to delete path: /data/user/0/com.anzogame.lol/tinker/patch.retry12-09 16:21:53.368 12198-12228/? I/Tinker.PatchFileUtil: safeDeleteFile, try to delete path: /data/user/0/com.anzogame.lol/tinker/temp.apk 看到如下日志，表示补丁合成成功，杀进程，重启应用，查看日志 TinkerLoader: tryLoadPatchFiles:isEnabledForResource:true12-09 16:24:00.771 12420-12420/? D/Tinker.TinkerInternals: same fingerprint:Xiaomi/gemini/gemini:6.0.1/MXB48T/V8.1.1.0.MAACNDI:user/release-keys12-09 16:24:00.775 12420-12420/? W/Tinker.TinkerLoader: tinker safe mode preferName:tinker_own_config_com.anzogame.lol count:012-09 16:24:00.780 12420-12420/? W/Tinker.TinkerLoader: after tinker safe mode count:112-09 16:24:00.780 12420-12420/? I/Tinker.TinkerDexLoader: classloader: dalvik.system.PathClassLoader[DexPathList[[zip file “/data/app/com.anzogame.lol-1/base.apk”],nativeLibraryDirectories=[/data/app/com.anzogame.lol-1/lib/arm, /data/app/com.anzogame.lol-1/base.apk!/lib/armeabi-v7a, /vendor/lib, /system/lib]]]12-09 16:24:00.806 12420-12420/? W/Tinker.ClassLoaderAdder: checkDexInstall result:true12-09 16:24:00.807 12420-12420/? I/Tinker.TinkerDexLoader: after loaded classloader: dalvik.system.PathClassLoader[DexPathList[[zip file “/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes.dex.jar”, zip file “/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes2.dex.jar”, zip file “/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes3.dex.jar”, zip file “/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/classes4.dex.jar”, zip file “/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/dex/test.dex.jar”, zip file “/data/app/com.anzogame.lol-1/base.apk”],nativeLibraryDirectories=[/data/app/com.anzogame.lol-1/lib/arm, /data/app/com.anzogame.lol-1/base.apk!/lib/armeabi-v7a, /vendor/lib, /system/lib]]]12-09 16:24:00.812 12420-12420/? E/Tinker.ResourcePatcher: checkResUpdate success, found test resource assets file only_use_to_test_tinker_resource.txt12-09 16:24:00.813 12420-12420/? I/Tinker.ResourceLoader: monkeyPatchExistingResources resource file:/data/user/0/com.anzogame.lol/tinker/patch-3ce34da5/res/resources.apk, use time: 612-09 16:24:00.813 12420-12420/? I/Tinker.TinkerLoader: tryLoadPatchFiles: load end, ok!12-09 16:24:00.845 12420-12420/? D/Tinker.DefaultAppLike: onBaseContextAttached:12-09 16:24:00.853 12420-12420/? I/Tinker.SamplePatchListener: application maxMemory:25612-09 16:24:00.858 12420-12420/? W/Tinker.Tinker: tinker patch directory: /data/user/0/com.anzogame.lol/tinker12-09 16:24:00.863 12420-12420/? I/Tinker.TinkerLoadResult: parseTinkerResult loadCode:012-09 16:24:00.863 12420-12420/? I/Tinker.TinkerLoadResult: parseTinkerResult oldVersion:, newVersion:3ce34da54e4e3ec20c9f8868a8970db0, current:3ce34da54e4e3ec20c9f8868a8970db012-09 16:24:00.863 12420-12420/? I/Tinker.TinkerLoadResult: oh yeah, tinker load all success12-09 16:24:00.863 12420-12420/? I/Tinker.DefaultLoadReporter: patch version change from to 3ce34da54e4e3ec20c9f8868a8970db012-09 16:24:00.863 12420-12420/? I/Tinker.DefaultLoadReporter: try kill all other process12-09 16:24:00.865 12420-12420/? I/Tinker.DefaultLoadReporter: patch load result, path:/data/user/0/com.anzogame.lol/tinker, code:0, cost:81 oh yeah, tinker load all success 补丁合成加载成功。 ###tinker 多渠道打包怎么处理？tinker 本身是支持flavor 打包的： 加入上面的配置，执行assembleRelease task, 会在app/build/bakApk/目录下面生成所有flavor 中的渠道包. 接着修改代码和资源文件，执行tinkerPatchAllFlavorRelease 生成所有渠道的补丁包 然在后在手机上执行通渠道的补丁升级，可以正常升级，如果你用tencent渠道的包升级test 渠道的补丁包，就会失败，什么原因呢？查看tinker文档 额。。。。 实际使用中不可能对不同渠道进行补丁包的管理，多个渠道需要使用一个补丁包，那么我们就需要对我们现在有的打包方式进行修改，tinker 的建议方式原理和美团的快速打包方案类似，那么我们来看下美团的打包方案。 ###美团打包方案传送门1传送门2 ###第一步：修改我们的多渠道flavors 打包方式去掉所有渠道，只剩下一个test渠道做为基础渠道，然后在启动APP的时候动态设置渠道值，例如可以用友盟提供的方式AnalyticsConfig.setChannel(ChannelUtil.getChannel(getCurrentActivity()));动态设置渠道值获取渠道代码 ###第二步：替换我们之前的获取渠道名称代码 AndroidApiUtils.getUmengChannel(Context context) , 改为友盟提供的方式AnalyticsConfig.getChannel(getApplicationContext()) ，因为我们以前的代码是直接读取的meta 中的与友盟渠道号 ,查看友盟的代码，AnalyticsConfig.getChannel 是在渠道号不为空的情况下才会去读取meta 中的，我们打包方式是不会对AndroidManifest.xml 中的渠道号做替换的，只是内存中的channel 替换。 ###第三步：打包生成apk ，在把生成APK 放到脚本同级的目录下面，进入目录执行python MultiChannelBuildTool.py生成apk， 不到一分钟，所有渠道的APK 已经生成好了,channel.txt 是所有渠道的渠道列表。 下面是打包脚本: 按照美团的打包方式生成基础APK 多渠道APK 补丁包，经验证补丁可以正常运行。 以后发版本打包的流程， 执行gradle clean assembleRelease -PDEV_PACKET=false 任务，release 目录下面生成基础版本的APK ,然后在当前目录下面实行python MultiChannelBuildTool.py ，同时在release 同级目录下面会生成 bakApk/…/ 备份的apk ，mapping.txt, R.txt 文件。 Tinker 常用API传送门 Tinker 自定义扩展传送门 Tinker 常见问题传送门 热补丁流程错误码定义：1，下载失败上报2，接口请求错误上报3，MD5文件校验失败错误上报5，文件格式校验错误上报6，补丁合成失败上报7，补丁合成成功上报 ##热补丁相关疑问？ ###tinker 热补丁和DroidPlug插件有什么区别？tinker 是热更新工具 目前补丁不支持新增四大组件 DroidPlug 核心思想是hook 系统流程，占坑实现插件。 ###tinker 的资源是怎么修复的？ ###tinker 的DEX是怎么修复的？ ###tinker 的so是怎么修复的？ ##Tinker 相关文章微信Tinker的一切都在这里，包括源码(一) Android_N混合编译与对热补丁影响解析 微信Android热补丁实践演进之路","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"热补丁","slug":"热补丁","permalink":"http://yoursite.com/tags/热补丁/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"hexo 个性化设置（大全）","slug":"Hexo美化","date":"2018-07-16T10:56:45.000Z","updated":"2018-07-19T14:05:35.000Z","comments":false,"path":"2018/07/16/Hexo美化/","link":"","permalink":"http://yoursite.com/2018/07/16/Hexo美化/","excerpt":"","text":"主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class=\"blockquote-center\"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: src1&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）123456789101112 .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 鼠标点击小红心的设置将 love.js 文件添加到 \\themes\\next\\source\\js\\src 文件目录下。找到 \\themes\\next\\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \\themes\\next\\source\\js\\src 文件目录下。找到 \\themes\\next\\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\\next\\source\\css_custom\\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置12345search: path: search.xml field: post format: html limit: 10000 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 加入动态背景首先找到\\themes\\next\\layout_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 1&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\" count=\"50\" zindex=\"-2\" opacity=\"1\" color=\"0,104,183\"&gt;&lt;/script&gt; 然后在themes\\source\\js\\src\\下新建文件particle.js写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(\"script\"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,\"zIndex\",-1),o:n(i,\"opacity\",.5),c:n(i,\"color\",\"0,0,0\"),n:n(i,\"count\",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=\"rgba(\"+m.c+\",\"+(t+.2)+\")\",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(\"canvas\"),m=t(),d=\"c_n\"+m.l,l=u.getContext(\"2d\"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=\"position:fixed;top:0;left:0;z-index:\"+m.z+\";opacity:\"+m.o,e(\"body\")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 修改字体大小打开\\themes\\next\\source\\css\\ _variables\\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base = 16px 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改 themes\\next\\source\\css_common\\components\\sidebar\\sidebar-author.styl123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; &lt;!-- (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();--&gt;&lt;/script&gt; 然后文章中添加：1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如:12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 MakeDown语法123456789101112131415161718[hexo](http://www.baidu.com) 表示超链接##大标题###小标题&lt;!-- more --&gt;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125;blah blah blah&#123;% endcq %&#125;空格 中文全角空格表示---文章标题---&gt;内容 区块引用*1*2*3列表*内容* 表示强调内容![Alt text](/path/to/img.jpg) 图片![](/upload_image/20161012/1.png)","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]},{"title":"RxJava基本使用","slug":"RxJava基本使用","date":"2018-07-16T10:56:45.000Z","updated":"2018-07-19T13:36:16.000Z","comments":false,"path":"2018/07/16/RxJava基本使用/","link":"","permalink":"http://yoursite.com/2018/07/16/RxJava基本使用/","excerpt":"","text":"优秀的人，不是不合群，而是他们合群的人里面没有你 RxJava是什么?开源地址 RxAndroid 要知道RxJava是什么，那么你应该先去了解一下Rx。Rx的全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。Rx已经渗透到了各个语言中，有了Rx所以才有了 RxJava，Rx.NET、RxJS、RxSwift、Rx.rb、RxPHP等等 官方描述 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库） RXJava 是基于观察者模式构建的 我们先把观察者模式说清楚 例如：“按下开关，台灯灯亮” 在这个事件中，台灯作为观察者，开关作为被观察者，台灯透过电线来观察开关的状态来并做出相应的处理 开关（被观察者）作为事件的产生方（生产“开”和“关”这两个事件），是主动的，是整个开灯事理流程的起点。 台灯（观察者）作为事件的处理方（处理“灯亮”和“灯灭”这两个事件），是被动的，是整个开灯事件流程的终点。 在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的（上图没有体现，后面对会讲到）。 响应式编程是什么？ 响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。 RxJava好在哪？例如：从服务器上拉去最新小区列表的需求，可能这样写：12345678910111213141516171819202122new Thread() &#123; @Override public void run() &#123; super.run(); //从服务端获取小区列表 List&lt;Community&gt; communities = getCommunitiesFromServer(); for (Community community : communities) &#123; List&lt;House&gt; houses = community.houses; for (House house : houses) &#123; if (house.price &gt;= 5000000) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); &#125; &#125; &#125; &#125; &#125;.start(); RxJava 这样写：1234567891011121314151617181920Observable.from(getCommunitiesFromServer()) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.houses); &#125; &#125;).filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.price&gt;=5000000; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); Lambda 简化：12345Observable.from(getCommunitiesFromServer()) .flatMap(community -&gt; Observable.from(community.houses)) .filter(house -&gt; house.price&gt;=5000000).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::addHouseInformationToScreen); RxJava基本元素RxJava基本使用操作符Create create 操作符应该是最常见的操作符了，主要用于产生一个 Obserable 被观察者对象，为了方便大家的认知，以后的教程中统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e(TAG, \"Observable emit 1\" + \"\\n\"); e.onNext(1); Log.e(TAG, \"Observable emit 2\" + \"\\n\"); e.onNext(2); Log.e(TAG, \"Observable emit 3\" + \"\\n\"); e.onNext(3); e.onComplete(); Log.e(TAG, \"Observable emit 4\" + \"\\n\" ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.e(TAG, \"onSubscribe : \" + d.isDisposed() + \"\\n\" ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; Log.e(TAG, \"onNext : value : \" + integer + \"\\n\" ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); Log.e(TAG, \"onNext : isDisposable : \" + mDisposable.isDisposed() + \"\\n\"); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.e(TAG, \"onError : value : \" + e.getMessage() + \"\\n\" ); &#125; @Override public void onComplete() &#123; Log.e(TAG, \"onComplete\" + \"\\n\" ); &#125; &#125;); 结果： 12345678onSubscribe : falseObservable emit 1onNext : value : 1Observable emit 2onNext : value : 2onNext : isDisposable : trueObservable emit 3Observable emit 4 Map 它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return \"This is result \" + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"accept : \" + s +\"\\n\"); Log.e(TAG, \"accept : \" + s +\"\\n\" ); &#125; &#125;); 结果： 12307-10 14:15:49.857 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 107-10 14:15:49.859 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 207-10 14:15:49.861 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 3 Concat简单来说就是连接两个或多个发射器，向一个发射器一样，他们不产生交叉 Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;concat : &quot;+ integer + &quot;\\n&quot; ); } }); 执行结果： 07-10 14:24:10.147 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 1 07-10 14:24:10.150 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 2 07-10 14:24:10.154 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 3 07-10 14:24:10.158 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 4 07-10 14:24:10.162 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 5 07-10 14:24:10.166 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 6 FlatMap transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); } }); 结果： ConcatMap concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证吧 Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); } }); 执行结果： Distinct顾名思义，去重操作符 Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\\n&quot;); } }); 执行结果： Filter emit only those items from an Observable that pass a predicate test Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() { @Override public boolean test(@NonNull Integer integer) throws Exception { return integer &gt;= 10; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;filter : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;filter : &quot; + integer + &quot;\\n&quot;); } }); 结果： just就是一个简单的发射器依次调用 onNext() 方法。 Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { mRxOperatorsText.append(&quot;accept : onNext : &quot; + s + &quot;\\n&quot;); Log.e(TAG,&quot;accept : onNext : &quot; + s + &quot;\\n&quot; ); } }); 结果： buffer periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a timebuffer 操作符接受两个参数，buffer(count,skip)，作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。 Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() { @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception { mRxOperatorsText.append(&quot;buffer size : &quot; + integers.size() + &quot;\\n&quot;); Log.e(TAG, &quot;buffer size : &quot; + integers.size() + &quot;\\n&quot;); mRxOperatorsText.append(&quot;buffer value : &quot;); Log.e(TAG, &quot;buffer value : &quot; ); for (Integer i : integers) { mRxOperatorsText.append(i + &quot;&quot;); Log.e(TAG, i + &quot;&quot;); } mRxOperatorsText.append(&quot;\\n&quot;); Log.e(TAG, &quot;\\n&quot;); } }); 结果： timer create an Observable that emits a particular item after a given delay Log.e(TAG, &quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); } }); 输出： Interval create an Observable that emits a sequence of integers spaced by a given time interval Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); } }); 输出： skip suppress the first n items emitted by an Observable 代表跳过 count 个数目开始接收。 Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;skip : &quot;+integer + &quot;\\n&quot;); Log.e(TAG, &quot;skip : &quot;+integer + &quot;\\n&quot;); } }); 结果： take emit only the first n items emitted by an Observable 接受一个 long 型参数 count ，代表至多接收 count 个数据 Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;take : &quot;+integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: take : &quot;+integer + &quot;\\n&quot; ); } }); 结果： Debounce only emit an item from an Observable if a particular timespan has passed without it emitting another item Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception { // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); } }).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;debounce :&quot; + integer + &quot;\\n&quot;); Log.e(TAG,&quot;debounce :&quot; + integer + &quot;\\n&quot;); } }); 结果： last emit only the last item (or the last item that meets some condition) emitted by an Observable last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 Observable.just(1, 2, 3) .last(4) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;last : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;last : &quot; + integer + &quot;\\n&quot;); } }); 结果： merge combine multiple Observables into one by merging their emissions merge 顾名思义，熟悉版本控制工具的你一定不会不知道 merge 命令，而在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。 Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;merge :&quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: merge :&quot; + integer + &quot;\\n&quot; ); } }); 结果： reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;reduce : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: reduce : &quot; + integer + &quot;\\n&quot;); } }); 结果： scan apply a function to each item emitted by an Observable, sequentially, and emit each successive value scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;scan &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: scan &quot; + integer + &quot;\\n&quot;); } }); 结果： zip combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/&quot;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()).build(); LolInterface lolInterfaceRequest = retrofit.create(LolInterface.class); Observable&lt;LolDataList&gt; observable1 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable&lt;LolDataList&gt; observable2 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;LolDataList, LolDataList, String&gt;() { @Override public String apply(@NonNull LolDataList lolDataList, @NonNull LolDataList lolDataList2) throws Exception { return &quot;合并后的数据为 lolDataList1=&quot;+lolDataList.getData().get(0).getDisplayName() + &quot;,lolDataList2=&quot;+lolDataList2.getData().get(0).getDisplayName(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;accept: 成功：&quot; + s+&quot;\\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;accept: 失败：&quot; + throwable+&quot;\\n&quot;); } }); 结果： accept: 成功：合并后的数据为 lolDataList1=灭世魔神 诺提勒斯,lolDataList2=灭世魔神 诺提勒斯 subScribeOn 指定的就是发射事件的线程 多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略 observeOn 指定的就是订阅者接收事件的线程。 多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次 线程切换Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); e.onNext(1); e.onComplete(); } }).subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(mainThread)，Current thread is &quot; + Thread.currentThread().getName()); } }) .observeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(io)，Current thread is &quot; + Thread.currentThread().getName()); } }); 结果： 07-14 11:43:11.669 8550-8611/com.nanchen.rxjava2examples E/RxThreadActivity: Observable thread is : RxNewThreadScheduler-1 07-14 11:43:11.670 8550-8550/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(mainThread)，Current thread is main 07-14 11:43:11.671 8550-8612/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(io)，Current thread is RxCachedThreadScheduler-2 场景举例 一个简单的网络请求 Observable.create(new ObservableOnSubscribe&lt;Response&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Response&gt; e) throws Exception { Builder builder = new Builder() .url(&quot;http://api.avatardata.cn/MobilePlace/LookUp?key=ec47b85086be4dc8b5d941f5abd37a4e&amp;mobileNumber=13021671512&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); Response response = call.execute(); e.onNext(response); Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); } }).map(new Function&lt;Response, MobileAddress&gt;() { @Override public MobileAddress apply(@NonNull Response response) throws Exception { Log.e(TAG, &quot;map 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { Log.e(TAG, &quot;map:转换前:&quot; + response.body()); return new Gson().fromJson(body.string(), MobileAddress.class); } } return null; } }).observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress s) throws Exception { Log.e(TAG, &quot;doOnNext 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Log.e(TAG, &quot;doOnNext: 保存成功：&quot; + s.toString() + &quot;\\n&quot;); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress data) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Log.e(TAG, &quot;成功:&quot; + data.toString() + &quot;\\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Log.e(TAG, &quot;失败：&quot; + throwable.getMessage() + &quot;\\n&quot;); } }); 执行结果： 07-13 09:13:08.664 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: map 线程:RxCachedThreadScheduler-1 map:转换前:okhttp3.internal.http.RealResponseBody@3e17a0f 07-13 09:13:08.691 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: create 线程:RxCachedThreadScheduler-1 07-13 09:13:08.691 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext 线程:main 07-13 09:13:08.702 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext: 保存成功：MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 07-13 09:13:08.737 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: subscribe 线程:main 07-13 09:13:08.741 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: 成功:MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 多个网络请求串行执行Observable.create(new ObservableOnSubscribe&lt;LolDataList&gt;() { @Override public void subscribe(ObservableEmitter&lt;LolDataList&gt; e) throws Exception { Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { LolDataList dataList = new Gson().fromJson(body.string(), LolDataList.class); e.onNext(dataList); } } } }).subscribeOn(Schedulers.io()) .doOnNext(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { // 处理数据保存逻辑 } }) .flatMap(new Function&lt;LolDataList, ObservableSource&lt;LolDataList&gt;&gt;() { @Override public ObservableSource&lt;LolDataList&gt; apply(LolDataList lolDataList) throws Exception { Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); LolDataList dataList = null; if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { dataList = new Gson().fromJson(body.string(), LolDataList.class); } } Log.e(TAG, &quot;flatMap 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); return Observable.just(dataList); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;+lolDataList.getData().size()); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(Throwable throwable) throws Exception { } }); 执行结果： 13 16:48:53.667 9180-9382/? E/RxCaseFlatMapActivity: create 线程:RxCachedThreadScheduler-2 07-13 16:48:54.104 9180-9382/? E/RxCaseFlatMapActivity: flatMap 线程:RxCachedThreadScheduler-2 07-13 16:48:54.105 9180-9180/? E/RxCaseFlatMapActivity: subscribe 线程:main6 间隔任务实现心跳mDisposable = Flowable.interval(1, TimeUnit.SECONDS) .doOnNext(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: doOnNext : &quot;+aLong ); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: 设置文本 ：&quot;+aLong ); mRxOperatorsText.append(&quot;accept: 设置文本 ：&quot;+aLong +&quot;\\n&quot;); } }); 结果： 07-14 11:01:19.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 0 07-14 11:01:19.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：0 07-14 11:01:20.048 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 1 07-14 11:01:20.050 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：1 07-14 11:01:21.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 2 07-14 11:01:21.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：2 07-14 11:01:22.049 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 3 07-14 11:01:22.051 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：3 资源链接RxJava文档中文版","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://yoursite.com/tags/RxJava/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Tinker 热补丁接入过程中的坑！！！","slug":"Tinker-接入","date":"2016-12-09T02:23:35.000Z","updated":"2018-07-19T13:56:15.000Z","comments":true,"path":"2016/12/09/Tinker-接入/","link":"","permalink":"http://yoursite.com/2016/12/09/Tinker-接入/","excerpt":"","text":"##Tinker 介绍 ##gradle 接入gradle是推荐的接入方式，在gradle插件tinker-patch-gradle-plugin中我们帮你完成proguard、multiDex以及Manifest处理等工作。 ##添加gradle依赖在项目的根目录build.gradle中，添加tinker-patch-gradle-plugin的依赖 引入tinker 核心库然后在baseUI-lib文件的build.gradle，我们需要添加tinker的库依赖以及apply tinker的gradle插件. 在APP/build.gradle 下面添加tinker 的配置文件 keep_in_main_dex.txt 文件内容就是指定你要放置到主DEX 中的类 -keep public class implements com.tencent.tinker.loader.app.ApplicationLifeCycle { ;} -keep public class extends com.tencent.tinker.loader.TinkerLoader { ;} -keep public class extends com.tencent.tinker.loader.app.TinkerApplication { } -keep class com.tencent.tinker.loader.* { ;} -keep class com.anzogame.corelib.GameApplication { *;} 运行APP 彩蛋….(Too many classes in –main-dex-list, main dex capacity exceeded) 为什么会这样子呢 ？ 我们已经采用了GOOGLE 的方案多DEX ,从报错上来看应该是主DEX 的类太多了，超过了限制，但是这个哪些类放到主DEX 不是我们决定的啊，很操蛋， 那么我们来看系统是如何分包的. ####在项目中，可以直接运行 gradle 的 task 。 collect{flavor}{buildType}MultiDexComponents Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 文件中去。 packageAll{flavor}DebugClassesForMultiDex Task 。该 task 是将所有类打包成 jar 文件存在 build/intermediates/multi-dex/{flavor}/debug/allclasses.jar 。 当 BuildType 为 Release 的时候，执行的是 proguard{flavor}Release Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 build/intermediates/classes-proguard/{flavor}/release/classes.jar shrink{flavor}{buildType}MultiDexComponents Task 。该 task 会根据 maindexlist.txt 生成 componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 build/intermediates/multi-dex/{flavor}/{buildType}/componentClasses.jar create{flavor}{buildType}MainDexClassList Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。 通过上面的流程我们可以得出 ，我们主DEX 中的类取决于build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中的内容 ，那么我们在执行MultiDexComponents task 时候做些拦截，把Activity 从主DEX中移除，这里面的移除不是全部移除，如果Activity中包含有子类，那么我们的移除是无效，还是会被放入到主DEX,另外，如果你 Application 、Service 、 Receiver 、 Provider 中的直接引用类还是会被放到第一个主DEX中。 当我们采用多DEX 的时候，应用启动的首先回加载主DEX ，其他的 dex 需要我们在应用启动后进行动态加载安装， 通过MultiDex.install(getApplication());加载其他DEX .Google 官方方案是如何加载的呢？ Google 官方支持 Multidex 的 jar 包是 android-support-multidex.jar，该 jar 包从 build tools 21.1 开始支持。这个 jar 加载 apk 中的从 dex 流程如下： 此处主要的工作就是从 apk 中提取出所有的从 dex（classes2.dex，classes3.dex，…），然后通过反射依次安装加载从 dex 并合并 DexPathList 的 Element 数组。 ##为什么API 21 以上就没有主DEX 过大的问题呢？ 这是为了5.0以上系统在安装过程中的art阶段就将所有的classes(..N).dex合并到一个单独的oat文件(5.0以下只能苦逼的启动时加载 对于Art相关知识，可以参考老罗的系列文章 传送门 ###DEX类分包的规则 我们开启多DEX支持一般是指定了multiDexEnabled，系统其实它利用的是Android sdk build tool中的mainDexClasses脚本，这在版本21以上才会有。使用方法非常很简单： mainDexClasses [–output ] 该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步：a. 环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。b. 使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。c. 通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表。 这里只是简单的得到所有入口类(即rules中的Instrumentation、application、Activity、Annotation等等)的直接引入类。何为直接引用类？在init过程，会在校验阶段去resolve它各个方法、变量引用到的类，这些类统称为某个类的直接引用类。举个栗子：12345public class MainActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState) &#123; DirectReferenceClass test = new DirectReferenceClass(); &#125;&#125; public class DirectReferenceClass { public DirectReferenceClass() { InDirectReferenceClass test = new InDirectReferenceClass(); }} public class InDirectReferenceClass { public InDirectReferenceClass() { }} 上面有MainActivity、DirectReferenceClass、InDirectReferenceClass三个类，其中DirectReferenceClass是MainActivity的直接引用类，InDirectReferenceClass是DirectReferenceClass的直接引用类。而InDirectReferenceClass是MainActivity的间接引用类(即直接引用类的所有直接引用类)。 对于5.0以下的系统，我们需要在启动时手动加载其他的dex。而我们并没有要求得到所有的间接引用类，这是因为我们在attachBaseContext的时候，已将其他dex加载。 事实上，若我们在attachBaseContext中调用Multidex.install，我们只需引入Application的直接引用类即可，mainDexClasses将Activity、ContentProvider、Service等的直接引用类也引入，主要是满足需要在非attachBaseContent加载多dex的需求。另一方面，若存在以下代码，将出现NoClassDefFoundError错误。 public class HelloMultiDexApplication extends Application { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); DirectReferenceClass test = new DirectReferenceClass(); MultiDex.install(this); }} 这是因为在实际运行过程中，DirectReferenceClass需要的InDirectReferenceClass并不一定在主dex。解决方法是手动将该类放于dx的-main-dex-list参数中： afterEvaluate { tasks.matching { it.name.startsWith(‘dex’) }.each { dx -&gt; if (dx.additionalParameters == null) { dx.additionalParameters = [] } dx.additionalParameters += ‘–multi-dex’ dx.additionalParameters += “–main-dex-list=$projectDir/“.toString() }} ##LinearAlloc 是什么 LinearAlloc 主要用来管理 Dalvik 中 class 加载时的内存，就是让 App 在执行时减少系统内存的占用。在 App 的安装过程中，系统会运行一个名为 dexopt 的程序为该应用在当前机型中运行做准备。dexopt 使用 LinearAlloc 来存储应用的方法信息。App 在执行前会将 class 读进 LinearAlloc 这个 buffer 中，这个 LinearAlloc 在 Android 2.3 之前是 4M 或 5M ，到 4.0 之后变为 8M 或 16M。因为 5M 实在是太小了，可能还没有 65536 就已经超过 5M 了，什么意思呢，就是只有一个包的情况下也有可能出现 INSTALL_FAILED_DEXOPT ，原因就在于 LinearAlloc。 ###解决 LinearAlloc DEXOPT &amp;&amp; DEX2OAT 是什么？ ###dexopt当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 apk路径 @ apk名 @ classes.dex 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。 更多可查看 Dalvik Optimization and Verification With dexopt 。 ####dex2oatAndroid Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。 更多可查看 Android运行时ART简要介绍和学习计划 。 ##Application Not Responding 因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 MultiDex.install() 操作是在 Application.attachBaseContext() 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 MultiDex.install() 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那又会 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。 引入dexnkife 核心库dexnkife 项目地址: DexKnifePlugin. dexnkife 帮助我们划分类到主DEX 首先在APP/目录下面新建dexknife.txt文件，用于配置dexknife ##在APP层添加Tinker的配置文件 ，配置文件如下： tinkerEnabled: tinker 的开关 ###tinker 多渠道打包怎么处理？tinker 本身是支持flavor 打包的： 加入上面的配置，执行assembleRelease task, 会在app/build/bakApk/目录下面生成所有flavor 中的渠道包. 接着修改代码和资源文件，执行tinkerPatchAllFlavorRelease 生成所有渠道的补丁包 然在后在手机上执行通渠道的补丁升级，可以正常升级，如果你用tencent渠道的包升级test 渠道的补丁包，就会失败，什么原因呢？查看tinker文档 额。。。。 实际使用中不可能对不同渠道进行补丁包的管理，多个渠道需要使用一个补丁包，那么我们就需要对我们现在有的打包方式进行修改，tinker 的建议方式原理和美团的快速打包方案类似，那么我们来看下美团的打包方案。 ###美团打包方案传送门1传送门2 ###第一步：修改我们的多渠道flavors 打包方式去掉所有渠道，只剩下一个test渠道做为基础渠道，然后在启动APP的时候动态设置渠道值，例如可以用友盟提供的方式AnalyticsConfig.setChannel(ChannelUtil.getChannel(getCurrentActivity()));动态设置渠道值获取渠道代码 ###第二步：替换我们之前的获取渠道名称代码 AndroidApiUtils.getUmengChannel(Context context) , 改为友盟提供的方式AnalyticsConfig.getChannel(getApplicationContext()) ，因为我们以前的代码是直接读取的meta 中的与友盟渠道号 ,查看友盟的代码，AnalyticsConfig.getChannel 是在渠道号不为空的情况下才会去读取meta 中的，我们打包方式是不会对AndroidManifest.xml 中的渠道号做替换的，只是内存中的channel 替换。 ###第三步：打包生成apk ，在把生成APK 放到脚本同级的目录下面，进入目录执行python MultiChannelBuildTool.py生成apk， 不到一分钟，所有渠道的APK 已经生成好了,channel.txt 是所有渠道的渠道列表。 下面是打包脚本: 按照美团的打包方式生成基础APK 多渠道APK 补丁包，经验证补丁可以正常运行。 以后发版本打包的流程， 执行gradle clean assembleRelease -PDEV_PACKET=false 任务，release 目录下面生成基础版本的APK ,然后在当前目录下面实行python MultiChannelBuildTool.py ，同时在release 同级目录下面会生成 bakApk/…/ 备份的apk ，mapping.txt, R.txt 文件。 ##热补丁接入相关疑问？ ###tinker 热补丁和DroidPlug插件有什么区别？tinker 是热更新工具 目前补丁不支持新增四大组件 DroidPlug 核心思想是hook 系统流程，占坑实现插件。 ###tinker 的资源是怎么修复的？ ###tinker 的DEX是怎么修复的？ ###tinker 的so是怎么修复的？ ###Android 中是怎么确认哪些类放到主DEX中的呢？ ##Tinker 相关文章微信Tinker的一切都在这里，包括源码(一) Android_N混合编译与对热补丁影响解析 微信Android热补丁实践演进之路","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"热补丁","slug":"热补丁","permalink":"http://yoursite.com/tags/热补丁/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]}]}