{"meta":{"title":"lee","subtitle":null,"description":"记录学习，生活中的点点滴滴...","author":"lee","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-07-18T14:51:45.000Z","updated":"2018-07-18T14:51:59.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-18T14:42:35.000Z","updated":"2018-07-18T14:43:27.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter 初探","slug":"Flutter-初探","date":"2018-11-13T03:08:45.000Z","updated":"2018-11-13T03:08:39.710Z","comments":true,"path":"2018/11/13/Flutter-初探/","link":"","permalink":"http://yoursite.com/2018/11/13/Flutter-初探/","excerpt":"","text":"Flutter 初探官网 https://flutter.io/中文网 https://flutterchina.club/ Flutter ,Weex , RN … 跨端开发方案 介绍 Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面，并且是未来新操作系统Fuchsia的默认开发套件。自从2017年5月发布第一个版本以来，目前Flutter已经发布了近60个版本，并且在2018年5月发布了第一个“Ready for Production Apps”的Beta 3版本，6月20日发布了第一个“Release Preview”版本，9月19日发布了Flutter Release Preview 2 版本，也是1.0之前的最后一个预览版本。 开发语言Dart 官网： https://www.dartlang.org 中文网：http://dart.goodev.org/guides/language/language-tour Dart是一种强类型、跨平台的客户端开发语言。具有专门为客户端优化、高生产力、快速高效、可移植（兼容ARM/x86）、易学的OO编程风格和原生支持响应式编程（Stream &amp; Future）等优秀特性。Dart主要由Google负责开发和维护，在2011年10启动项目，2017年9月发布第一个2.0-dev版本。 为什么选择dart 做为Flutter开发语言? dart 团队在flutter团队旁边，支持更有效 dart具有jit&amp;Aot双重编译执行方式。这样就能利用JIt进行开发阶段的hot reload开发，提升研发效率。同时在最终release版本中使用aot将dart代码直接变成目标平台的指令集代码。简单高效，最大限度保障了性能 dart针对flutter中频繁创建销毁Widget的场景做了专门的gc优化。通过分代无锁垃圾回收器，将gc对性能的影响降至最低 dart语言在语法上面是类java的，易学易用 健全的类型系统，同时支持静态类型检查和运行时类型检查 丰富的底层库，Dart自身提供了非常多的库 DartVM的内存分配Flutter对Dart源码做了AOT编译，直接将Dart源码编译成了本地字节码，没有了解释执行的过程，提升执行性能,Dart的”线程”(Isolate)是不共享内存的，各自的堆(Heap)和栈(Stack)都是隔离的，这种分配策略可以让Dart实现无锁的快速分配 ,而彼此之间通过消息通道来通信, Dart VM将内存管理分为新生代(New Generation)和老年代(Old Generation)。 新生代(New Generation): 通常初次分配的对象都位于新生代中，该区域主要是存放内存较小并且生命周期较短的对象，比如局部变量。新生代会频繁执行内存回收(GC)，回收采用“复制-清除”算法，将内存分为两块(图中的from 和 to)，运行时每次只使用其中的一块(图中的from)，另一块备用(图中的to)。当发生GC时，将当前使用的内存块中存活的对象拷贝到备用内存块中，然后清除当前使用内存块，最后，交换两块内存的角色。 老年代(Old Generation): 在新生代的GC中“幸存”下来的对象，它们会被转移到老年代中。老年代存放生命力周期较长，内存较大的对象。老年代通常比新生代要大很多。老年代的GC回收采用“标记-清除”算法，分成标记和清除两个阶段。在标记阶段，所有线程参与并发的完成对回收对象的标记，降低标记阶段耗时。在清理阶段，由GC线程负责清理回收对象，和应用线程同时执行，不影响应用运行 Flutter 架构 StatelessWidget 和 StatefulWidget的区别 StatelessWidget是状态不可变的widget。初始状态设置以后就不可再变化。如果需要变化需要重新创建。StatefulWidget可以保存自己的状态。那问题是既然widget都是immutable的，怎么保存状态？其实Flutter是通过引入了State来保存状态。当State的状态改变时，能重新构建本节点以及孩子的Widget树来进行UI变化。注意：如果需要主动改变State的状态，需要通过setState()方法进行触发，单纯改变数据是不会引发UI改变的 StatefulWidget state生命周期 didChangeDependencies有两种情况会被调用。 创建时候在initState 之后被调用 在依赖的InheritedWidget发生变化的时候会被调用,正常的退出流程中会执行deactivate然后执行dispose。 但是也会出现deactivate以后不执行dispose，直接加入树中的另一个节点的情况。 这里的状态改变包括两种可能： 通过setState内容改变 父节点的state状态改变，导致孩子节点的同步变化 widget 基础组件一切即Widget。在flutter的世界里，包括views,view controllers,layouts等在内的概念都建立在Widget之上。 Container容器，一个常用的控件，由基本的绘制、位置和大小控件组成。负责创建矩形的可视元素，可以用BoxDecoration来设计样式，比如背景、边框和阴影，Container也有边距、填充和大小限制，另外，还可以在三维空间利用矩阵进行变换 1234567891011121314BaseWidget.dart Container container = new Container( constraints: new BoxConstraints.expand( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 100.0, ), color: Colors.teal.shade700, alignment: Alignment.center, child: new Text('Hello World', style: Theme.of(context).textTheme.display1.copyWith(color: Colors.white)), );``` ##### Stack 一个控件叠在另一个控件的上面 DisplayImage.dartStack( // Aligment 的取值范围为 [-1, 1]，Stack 中心为 (0, 0)， // 这里设置为 (-0.5, -0.5) 后，可以让文本对齐到 Container 的 1/4 处 alignment: const Alignment(-0.5, -0.5), children: [ Container( width: 200.0, height: 200.0, color: Colors.blue, ), Text(‘foobar’), ], ); 123456##### Rowflex水平布局控件，能够将子控件水平排列，是基于Web的flexbox的布局模式设计的。Row子控件有灵活与不灵活的两种，Row首先列出不灵活的子控件，减去它们的总宽度，计算还有多少可用的空间。然后Row按照Flexible.flex属性确定的比例在可用空间中列出灵活的子控件。要控制灵活子控件，需要使用Expanded控件 BaseWidget.dartRow row = new Row( children: [ new Expanded( flex : 1, child: new Text(‘Deliver features faster’, textAlign: TextAlign.center), ), new Expanded( flex : 1, child: new Text(‘Craft beautiful UIs’, textAlign: TextAlign.center), ), new Expanded( flex : 2, child: new FittedBox( fit: BoxFit.contain, // otherwise the logo will be tiny child: const FlutterLogo(), ), ), ], );123456789101112131415161718192021222324252627![](https://jekton.github.io/2018/08/26/flutter-ui-basic/row-diagram.png)![](https://jekton.github.io/2018/08/26/flutter-ui-basic/column-diagram.png)##### Text Container( child: Center( child: Text('hello world hello world hello world hello world hello world ' , textAlign: TextAlign.center, overflow: TextOverflow.ellipsis, style: TextStyle( color: Colors.red, fontSize: 30.0, letterSpacing: 2.0, fontFamily: 'Raleway', fontStyle: FontStyle.normal ),), ), )结果：![屏幕快照 2018-10-29 上午10.32.53.png](https://upload-images.jianshu.io/upload_images/1656668-b03c2b60542144e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### TextField ，Checkbox ，Switch，AlertDialog，RaisedButton , FlatButton BaseWidget.dart TextField textFormField = TextField( decoration: InputDecoration( labelText: “you select is ${isTrue == true ? “true “ : “false”}”, ), onChanged: (str){ setState(() { textContent = str; }); }, ); Checkbox checkbox = Checkbox( value: isTrue, onChanged: (bool) { setState(() { isTrue = bool; }); }); Switch witch = Switch( value: isTrue, onChanged: (bool) { setState(() { isTrue = bool; }); }, ); AlertDialog alertDialog = AlertDialog( title: Text(&apos;标题&apos;), content: Text(textContent), ); var flatBtn = FlatButton( onPressed: () =&gt; print(&apos;FlatButton pressed&apos;), child: Text(&apos;BUTTON&apos;), ); 1234#### Icon在Flutter中默认为大家提供了很多自带的小图标，我们可以根据自己的需要去选择这些图标Icon的构造方法 const Icon(this.icon//IconDate, { Key key, this.size,//大小 this.color,//颜色 this.semanticLabel,//标志位 this.textDirection,//绘制方向，一般使用不到 }) 在Flutter内部为我们提供了material_fonts，在安装目录flutter\\bin\\cache\\artifacts\\material_fonts下在Flutter中，我们可以根据Icons中定义的图标来进行引入，在Icon是中大概定义了1000个左右的Icon。使用内置Icon图片代码 new Center( child: new Icon(Icons.android,size: 100.0), )1234567891011使用第三方图标制作字体库- https://icomoon.io/app/#/select- http://iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a![](http://ww1.sinaimg.cn/large/0060lm7Tly1fp6jesi910j30kk091jui.jpg)#### GridView GridView.dart GridView.count( primary: false, scrollDirection: Axis.vertical, padding: EdgeInsets.all(2.0), crossAxisCount: 2, children: [ makeCardView(Icons.add, ‘add’), makeCardView(Icons.list, ‘list’), makeCardView(Icons.map, ‘map’), makeCardView(Icons.close, ‘close’), makeCardView(Icons.share, ‘share’), makeCardView(Icons.star, ‘start’), makeCardView(Icons.add, ‘add’), makeCardView(Icons.list, ‘list’), makeCardView(Icons.map, ‘map’), makeCardView(Icons.close, ‘close’), makeCardView(Icons.share, ‘share’), makeCardView(Icons.star, ‘start’), ], );123#### 图片加载使用 Image，可以让我们向用户展示一张图片。图片的来源可以是网络、文件、资源和内存，它们对应的构造函数分别是 Image.asset(name);Image.file(file);Image.memory(bytes);Image.network(src); DisplayImage.dart @override Widget build(BuildContext context) { final url = “https://gw.alicdn.com/tfs/TB1SZxwBuuSBuNjy1XcXXcYjFXa-828-374.png&quot;; return MaterialApp( title: ‘display image’, home: Scaffold( appBar: AppBar( title: new Text(‘display image’), ), body: Image.network(url), ), ); } 1234#### 动画##### CurvedAnimation TestAnimationUI.dart class _MyFadeTest extends State with TickerProviderStateMixin { AnimationController controller; CurvedAnimation curve; @override void initState() { controller = new AnimationController(duration: const Duration(milliseconds: 2000), vsync: this); curve = new CurvedAnimation(parent: controller, curve: Curves.elasticInOut); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Container( child: new FadeTransition( opacity: curve, child: new FlutterLogo( size: 100.0, )))), floatingActionButton: new FloatingActionButton( tooltip: ‘Fade’, child: new Icon(Icons.brush), onPressed: () { controller.forward(); }, ), ); }}12#### InkWell 水波纹效果 InkWell.dartnew InkWell( // When the user taps the button, show a snackbar onTap: () { Scaffold.of(context).showSnackBar(new SnackBar( content: new Text(‘Tap’), )); }, child: new Container( padding: new EdgeInsets.all(12.0), child: new Text(‘Flat Button’), ), );123#### SharedPreferences在pubspec.yaml 文件中引入SharedPreferences 插件 dependencies: flutter: sdk: flutter The following adds the Cupertino Icons font to your application.Use with the CupertinoIcons class for iOS style icons. cupertino_icons: ^0.1.2 shared_preferences: “0.4.2” 1例子： share_preference_demo.dart void saveSharedPrefence() async { SharedPreferences sharedPreferences = await _sPres; listOne.add(textEditingController.text); sharedPreferences.setStringList(“list”, listOne); textEditingController.clear(); } void clearSharedPrefence() async { SharedPreferences sharedPreferences = await _sPres; sharedPreferences.clear(); setState(() { listOne = []; listTwo = []; }); } void getString () async { SharedPreferences sharedPreferences = await _sPres; listTwo = sharedPreferences.getStringList(“list”); setState(() { }); }12345678910111213141516171819202122232425262728293031323334353637383940#### 异步和线程##### isolate[官方文档](https://api.dartlang.org/stable/1.24.3/dart-isolate/dart-isolate-library.html)Dart是基于单线程模型的语言。在Dart中有一个很重要的概念叫isolate，它其实就是一个线程或者进程的实现，具体取决于Dart的实现。默认情况下，我们用Dart写的应用都是运行在main isolate中的（可以对应理解为Android中的main thread）。当然我们在必要的时候也可以通过isolate API创建新的isolate，多个isolate可以更好的利用多核CPU的特性来提高效率。但是要注意的是在Dart中isolate之间是无法直接共享内存的，不同的isolate之间只能通过isolate API进行通信。##### event loop[官方文档](https://webdev.dartlang.org/articles/performance/event-loop)在Dart运行环境中也是靠事件驱动的 ,通过event loop不停的从队列中获取消息或者事件来驱动整个应用的运行。但是不同点在于一个Dart编写的app中一般有两个队列，一个叫做event queue，另一个叫做microtask queue.- event queue包含所有外来的事件：I/O，mouse events，drawing events，timers，isolate之间的message等。任意isolate中新增的event（I/O，mouse events，drawing events，timers，isolate的message）都会放入event queue中排队等待执行.- microtask queue只在当前isolate的任务队列中排队，优先级高于event queue![](https://webdev.dartlang.org/articles/performance/images/both-queues.png)这张图以main isolate为例，描述了app运行时一个isolate中的正常运行流程。- 启动app。首先执行main方法。- 在main方法执行完后，开始处理microtask queue，从中取出microtask执行，直到microtask queue为空。这里可以看到event loop在运行时是优先处理microtask queue的。- 当microtask queue为空才会开始处理event queue，如果event queue不为空则从中取出一个event执行。- 这里要注意的是event queue并不会一直遍历完，而是一次取出一个event执行，执行完后就回到前面去重新判断microtask queue是否为空。- 所以这里可以看到microtask queue存在的一个重要意义是由它的运行时机决定的，当我们想要在处理当前的event之后，并且在处理下一个event之前做一些事情，或者我们想要在处理所有event之前做一些事情，这时候可以将这些事情放到microtask queue中。- 当microtask queue和event queue都为空时，app可以正常退出。&gt;&gt;Note:当event loop在处理microtask queue时，会阻塞住event queue。绘制和交互等任务是作为event存放在event queue中的，所以当microtask queue中任务太多或处理时长太长，将会导致应用的绘制和交互等行为被卡住。##### feture async await- Future是Dart中提供的一个类，它用于封装一段在将来会被执行的代码逻辑。构造一个Future就会向event queue中添加一条记录- 在Dart中我们可以通过async关键字来声明一个异步方法，异步方法会在调用后立即返回给调用者一个Future对象,而异步方法的方法体将会在后续被执行- await表达式的表达式部分通常是一个Future类型，即在await处挂起后交出代码的执行权限直到该Future完成。在Future完成后将包含在Future内部的数据类型作为整个await表达式的返回值，接着异步方法继续从await表达式挂起点后继续执行例子： import &apos;dart:async&apos;; Future&lt;void&gt; printDailyNewsDigest() async { var newsDigest = await gatherNewsReports(); print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print(&apos;Winning lotto numbers: [23, 63, 87, 26, 2]&apos;); } printWeatherForecast() { print(&quot;Tomorrow&apos;s forecast: 70F, sunny.&quot;); } printBaseballScore() { print(&apos;Baseball score: Red Sox 10, Yankees 0&apos;); } const news = &apos;&lt;gathered news goes here&gt;&apos;; const oneSecond = Duration(seconds: 1); 执行结果： Winning lotto numbers: [23, 63, 87, 26, 2] Tomorrow&apos;s forecast: 70F, sunny. Baseball score: Red Sox 10, Yankees 0 &lt;gathered news goes here&gt; 123![](https://www.dartlang.org/tutorials/images/async-await.png)then()操作 main() async { await printDailyNewsDigest(); await printWinningLotteryNumbers(); doSomethingWith(await printWeatherForecast());} printDailyNewsDigest() .then((aValue) =&gt; printWinningLotteryNumbers()) .then((bValue) =&gt; printWeatherForecast()) .then((cValue) =&gt; printBaseballScore()); 结果： Winning lotto numbers: [23, 63, 87, 26, 2]Tomorrow’s forecast: 70F, sunny.Baseball score: Red Sox 10, Yankees 0 1##### 网络请求和response 解析 GetData.dart import ‘package:flutter/material.dart’;import ‘package:flutter/rendering.dart’;import ‘package:http/http.dart’ as http;import ‘dart:async’;import ‘dart:convert’; main(){ debugPaintSizeEnabled=true; runApp(MaterialApp( title: ‘fetch get data’, home: new MyApp(), ));} Future fetchGet() async{ final response = await http.get( ‘https://jsonplaceholder.typicode.com/posts/1&#39;, headers: {“key”:”value1”} ); if(response.statusCode == 200){ return Get.formJson(json.decode(response.body)); }else{ throw Exception(‘Failed to load post’); }} class Get{ final int userId; final int id; final String title; final String body; Get({this.userId, this.id, this.title, this.body}); factory Get.formJson(Map maps){ return Get(userId:maps[‘userId’], id:maps[‘id’], title:maps[‘title’], body:maps[‘body’]); }} class MyApp extends StatelessWidget{ @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(‘fetch get data’), ), body: Center( child: FutureBuilder( future: fetchGet(), builder: (context,snapshot){ if (snapshot.hasData) { return Text(snapshot.data.title); } else if (snapshot.hasError) { return Text(“${snapshot.error}”); } // By default, show a loading spinner return CircularProgressIndicator(); }), ), ); } }12345##### 如何创建一个新isolate例子：async_new_isolate.dart loadData() async { print(‘loadData…’); ReceivePort receivePort = new ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // 获取到子线层sendPort SendPort sendPort = await receivePort.first; print(&apos;sendPort: $sendPort&apos;); List msg = await sendReceive(sendPort, &quot;https://jsonplaceholder.typicode.com/posts&quot;); print(&apos;list msg: $msg&apos;); setState(() { widgets = msg; }); } // the entry point for the isolate static dataLoader(SendPort sendPort) async { print(‘dataLoader…’); // Open the ReceivePort for incoming messages. ReceivePort port = new ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (var msg in port) { print(&apos;msg: $msg&apos;); String data = msg[0]; SendPort replyTo = msg[1]; String dataURL = data; http.Response response = await http.get(dataURL); // Lots of JSON to parse final bodyStr = json.decode(response.body); print(&apos;callback msg: &apos;); replyTo.send(json.decode(response.body)); } } Future sendReceive(SendPort port, msg) { ReceivePort response = new ReceivePort(); print(‘send msg: $msg’); port.send([msg, response.sendPort]); return response.first; } 执行结果：I/flutter (28815): loadData…I/flutter (28815): dataLoader…I/flutter (28815): sendPort: SendPortI/flutter (28815): send msg: https://jsonplaceholder.typicode.com/postsI/flutter (28815): msg: [https://jsonplaceholder.typicode.com/posts, SendPort]I/flutter (28815): callback msg:I/flutter (28815): list msg:` 综合案例Flutter 插件库官网dio 性能闲鱼Flutter VS RN 对比美团文章 flutter 问题？包大小增大Android的Apk增加8M，iOS压缩包增加16M。 Flutter 资源库https://github.com/xitu/awesome-flutter","categories":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"}],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/categories/flutter/"}]},{"title":"","slug":"android-开发快捷键","date":"2018-11-12T09:21:14.975Z","updated":"2018-11-12T09:29:09.681Z","comments":true,"path":"2018/11/12/android-开发快捷键/","link":"","permalink":"http://yoursite.com/2018/11/12/android-开发快捷键/","excerpt":"","text":"android 开发快捷键Android 安卓有关的 12345678910111213141516171819202122232425262728 const 常量 fbc findViewById fore 创建foreach循环 //修改了快捷键名称 gone 设置View为gone //修改了快捷键名称 IntentView 用ACTION_VIEW创建一个Intent key 结果是 private static final String KEY_$value$ = \"$value$\"; newInstance 使用参数创建一个新的Fragment实例 co 生成构造方法 //修改了快捷键名称 cop 私有构造方法 //修改了快捷键名称 rgS 从资源文件getString(R.string.XXX) rouiT 生成runOnUIThread sbc 生成方格状注释代码块 Sfmt 格式化String String.format(XXX) starter 创建一个静态的start（...）方法来启动一个Activity toal 创建一个长时间的Toast //新增 toas 创建一个Toast //修改了快捷键名称 vi 设置View为visible //修改了快捷键名称 logd Log.d(TAG, String)loge Log.e(TAG, String)logi Log.i(TAG, String)logm 打印方法名称及其参数,Log.d(TAG,XXX)logr 打印方法的结果psf public static final psfi public static final int psfs public static final String St String thr throw new AndroidComments 安卓组件 12fix 添加 // FIXME //修改了快捷键名称 do 添加 // TODO //修改了快捷键名称 12345678910111213141516171819202122232425262728293031323334353637383940iterations 快速生成循环和迭代器代码块for 示例：for (int i = 0; i &lt; ; i++) &#123;&#125; //修改了快捷键名称fora 示例：遍历数组 //修改了快捷键名称for (int i = 0; i &lt; Array.length; i++) &#123; int i1 = Array[i];&#125;forc 示例：使用iterator遍历一个容器变量 //修改了快捷键名称for (Iterator iterator = collection.iterator(); iterator.hasNext(); ) &#123; Object next = iterator.next();&#125;//这个是遍历一个容器变量的，直接让容器返回一个iterator进行遍历whe 示例：while循环遍历枚举内容 //修改了快捷键名称while (枚举类.hasMoreElements()) &#123; Object nextElement = 枚举类.nextElement();&#125;iter 示例：遍历选中状态下的set //修改了快捷键名称for (int i : FOCUSED_STATE_SET) &#123;...&#125;whi 示例：while循环使用iterator进行遍历 //修改了快捷键名称while (iterator.hasNext()) &#123; Object next = iterator.next();&#125;//获取到了迭代器对象后，对迭代器进行遍历操作forl 示例：遍历list对象里面的内容 //修改了快捷键名称for (int i = 0; i &lt; list.size(); i++) &#123; Object o = list.get(i);&#125;foraa 示例：倒叙遍历数组 //修改了快捷键名称for (int i = Array.length - 1; i &gt;= 0; i--) &#123; int i1 = FOCUSED_STATE_SET[i];&#125;//以下这两个用的少，只是把快捷键改了一下，方便使用fors 对StringTokenizer遍历 //修改了快捷键名称forv 对Vector遍历 //修改了快捷键名称","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Flutter-开发小知识","date":"2018-10-25T07:52:05.555Z","updated":"2018-10-25T07:52:05.555Z","comments":true,"path":"2018/10/25/Flutter-开发小知识/","link":"","permalink":"http://yoursite.com/2018/10/25/Flutter-开发小知识/","excerpt":"","text":"Flutter 开发小知识全屏Splash Flutter官方自带的splash启动页是在android或者ios的文件里面设置，但是不能添加倒计时之类的效果，自己做启动页需要全屏效果显示的时候，调用SystemChrome.setEnabledSystemUIOverlays([]); 这个方法把状态栏和虚拟按键隐藏掉，跳转到其他页面后需要调用SystemChrome.setEnabledSystemUIOverlays([SystemUiOverlay.top]);把状态栏显示出来，需要一起调用底部虚拟按键（华为系列某些手机有虚拟按键），则SystemChrome.setEnabledSystemUIOverlays([SystemUiOverlay.top, SystemUiOverlay.bottom]);","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Android工程添加flutter编译","date":"2018-10-23T10:14:09.144Z","updated":"2018-11-01T06:44:14.641Z","comments":true,"path":"2018/10/23/Android工程添加flutter编译/","link":"","permalink":"http://yoursite.com/2018/10/23/Android工程添加flutter编译/","excerpt":"","text":"Android工程集成flutter官方方案https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps 第一个步：新建一个标准的APP工程testFlutterInAPP，APP目录下面通过命令创建flutter模块工程 flutter create -t module my_flutter 编译flutter 代码生成Android的AAR文件 $ cd .android/ $ ./gradlew flutter:assembleDebug AAR 文件生成到.android/Flutter/build/outputs/aar/目录下面 添加Host APP 依赖flutter module 模块，在setting.gradle 文件中加入 include &apos;:app&apos; // assumed existing content setBinding(new Binding([gradle: this])) // new evaluate(new File( // new settingsDir.parentFile, // new &apos;my_flutter/.android/include_flutter.groovy&apos; // new )) app/build.gradle 增加对flutter 工程依赖 // testFlutterInAPP/app/build.gradle dependencies { implementation project(&apos;:flutter&apos;) } 构建成功后，执行Android的run启动应用 ,点击打开flutter 。 Java 层代码 12345678910111213141516 openFlutter.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; View flutterView = Flutter.createView( MainActivity.this, getLifecycle(), \"route1\" ); FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(600, 800); layout.leftMargin = 100; layout.topMargin = 200; addContentView(flutterView, layout); &#125; &#125;);``` flutter 代码 import ‘dart:ui’; import ‘package:flutter/material.dart’; void main() =&gt; runApp(_widgetForRoute(window.defaultRouteName)); Widget _widgetForRoute(String route) { switch (route) { case ‘route1’: return new MyApp(); case ‘route2’: return new MyApp(); default: return Center( child: Text(‘Unknown route1 : $route’, textDirection: TextDirection.ltr), ); } return new MyApp();} class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return new MaterialApp( title: ‘Flutter Demo’, theme: new ThemeData( primarySwatch: Colors.blue, ), home: new MyHomePage(title: ‘Flutter Demo 1111’ ‘Home Page’), ); }} class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; new _MyHomePageState();} class _MyHomePageState extends State { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text( &apos;You have pushed the button this many times:&apos;, ), new Text( &apos;$_counter&apos;, style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: &apos;Increment&apos;, child: new Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); }}`运行 flutter 工程 ，进入my_flutter 目录执行flutter run 命令 即可启动flutter ，r == hot reload R == hot restart q == quit d == detach, 或者启动Android应用调试 但是，好像DEBUG无效？？ 闲鱼方案连接 https://zhuanlan.zhihu.com/p/40528502","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"那些年你遇到的gradle-错误？","date":"2018-09-14T08:44:12.781Z","updated":"2018-09-17T09:22:16.191Z","comments":true,"path":"2018/09/14/那些年你遇到的gradle-错误？/","link":"","permalink":"http://yoursite.com/2018/09/14/那些年你遇到的gradle-错误？/","excerpt":"","text":"Flutter 基础组件Dart语法","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Nexus搭建Maven私服","date":"2018-09-13T08:22:27.998Z","updated":"2018-10-12T02:44:22.523Z","comments":true,"path":"2018/09/13/Nexus搭建Maven私服/","link":"","permalink":"http://yoursite.com/2018/09/13/Nexus搭建Maven私服/","excerpt":"","text":"Android-Nexus 搭建自己的 Maven 仓库 &amp; Gradle 上传依赖包####Maven 的介绍 从 Maven 的依赖下载管理角度来看，Maven 仓库的可分为两类，远程仓库和本地仓库。 本地仓库是电脑硬盘上的一个目录，远程仓库是在指放在远程服务器上电脑硬盘上的 Maven 仓库目录，使用需添加远程仓库的地址，才能正常连接下载依赖。 Maven 的远程仓库分为中央仓库和私服仓库。中央仓库存放了世界各地用户上传的依赖包，比较出名的是 JCenter 和 Maven Central，开源的第三方依赖一般都会上传到这两个中央仓库，这样我们只用添加这两个中央仓库的链接地址，就可以下载各种我们需要的依赖了。 由于每次构建都需要从中央仓库下载依赖，对于中央仓库的服务器来说，压力很大，间接导致下载速度很慢。并且，上传到中央仓库的依赖都是开源的，只要知道名字，用户就都能下载，虽然开源精神是值得倡导的，但是一些公司内部的核心依赖包，出于一些考虑，无法直接开源。于是，私服仓库就诞生了。在公司的局域网，搭建一个 Nexus 仓库，把公司内部不想开源的依赖包上传到私服仓库中，这样下载依赖的需满足两个条件，私服仓库的地址和在公司局域网内，一定程度上有个保密和安全性。 私服是一种特殊的远程仓库 私服是一种特殊的远程仓库, 它设在局域网内, 通过代理广域网上的远程仓库, 供局域网内的 Maven 用户使用。私服的存在，特殊于，它改变了 Maven 下载依赖的机制。 只有本地仓库和远程中央仓库时，当 Maven 根据坐标寻找依赖包时, 首先会检索本地仓库, 如果本地存在则直接使用, 否则去远程仓库下载. 但是，当有了一个私服后： 当检索本地仓库发现不存在的时候， Maven 客户端先向私服请求, 如果私服不存在该依赖包, 则从外部的远程仓库下载, 并缓存在私服上, 再为客户提供下载服务。简单的理解是私服相当于本地仓库和远程中央仓库的中间缓存，因此，私服的存在，可以节省公网带宽，利用内网下载依赖项速度快。 下面是一张本地仓库，私服仓库和远程中央仓库的依赖下载示意图（构件可理解为三方的依赖包，是比较专业的说法）： ####Nexus 搭建私服 官网：https://www.sonatype.com/download-oss-sonatype 下载 nexus-3.13.0-01 版本 安装帮助文档如下，过程比较简单，按照执行即可 java 环境需要1.8 https://help.sonatype.com/repomanager3/installation 安装成功之后，启动nexus 服务器可以通过http://ip:8081/的访问如果不能访问，关闭防火墙再试。 Androidstudio 工程AAR上传Android中上传AAR是通过gradle中增加人物的方式实现上传的，首先在依赖module的build.gradle中增加 pom中GROUP，POM_ARTIFACT_ID 在module目录下的gradle.propertis文件中配置 HAIXUE_LIB_VERSION_NAME, NEXUS_USERNAME, NEXUS_PASSWORD,在项目目录的config/dependencies 目录下面配置 所有子module都配好，点击右侧的gradle任务栏中的upload/uploadArchives 任务执行上传任务，点击项目根目录的upload/uploadArchives 则会遍历所有子module 上传编译后的aar ，上传成功后，到nexus的服务器上查看 AAR已经上传成功，注意同一个版本的库文件，只能上传一次，第二次则会出错，也避免库文件被异常覆盖 AAR 文件引用在项目的根目录的build.gradle 文件中配置 123456789101112maven &#123; url \"http://192.168.16.219:8081/repository/maven-public\" credentials &#123; username = \"admin\" password = \"admin123\" &#125; &#125; // module 中引用AARimplementation \"com.lzy.imagepicker:imagepicker:$&#123;haixueLibVersion&#125;\" haixueLibVersion是定义的统一版本，因为模块之间存在的依赖关系，比如:依赖关系A-&gt;B-&gt;C那么A,B,C 三个模块生成AAR之后，如果其中的A发生了变更升级版本，那么同时B,C 也需要同时跟着升级。 我们的使用规则？目前我们 清除gradle缓存 //Windows用这个gradlew build –refresh-dependencies//Mac用这个./gradlew build –refresh-dependencies","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"kotlin-开源项目整理","date":"2018-09-05T13:52:48.963Z","updated":"2018-09-05T15:08:55.221Z","comments":true,"path":"2018/09/05/kotlin-开源项目整理/","link":"","permalink":"http://yoursite.com/2018/09/05/kotlin-开源项目整理/","excerpt":"","text":"kotlin 开源整理github 上开源代码热度https://github.com/trending/kotlin 开源第三方组件库material-dialogs A beautiful, fluid, and customizable dialogs API for Kotlin GankClient-Kotlin CrunchyCalendar A beautiful material calendar with endless scroll, range selection and a lot more! gank.io kotlin实现的干货集中营客户端风格采用了Material Design. 多数控件都是design包里面的。 WanAndroid 项目采用 Kotlin 语言，基于 MVP + RxJava + Retrofit + Glide + EventBus 等架构设计，努力打造一款优秀的 http://www.wanandroid.com 客户端 MvRx MvRx: Android on Autopilot Eyepetizer kotlin仿开眼app 学习kotlin mvp retrofit rxjava android-sunflower A gardening app illustrating Android development best practices with Android Jetpack. shadowsocks A shadowsocks client for Android","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Dagger2-基本使用","date":"2018-09-05T07:44:54.256Z","updated":"2018-09-05T07:44:55.075Z","comments":true,"path":"2018/09/05/Dagger2-基本使用/","link":"","permalink":"http://yoursite.com/2018/09/05/Dagger2-基本使用/","excerpt":"","text":"Dagger2官网","categories":[],"tags":[],"keywords":[]},{"title":"Android 开源库收集","slug":"Android开源库收集","date":"2018-09-02T01:09:11.000Z","updated":"2018-09-02T02:27:59.483Z","comments":true,"path":"2018/09/02/Android开源库收集/","link":"","permalink":"http://yoursite.com/2018/09/02/Android开源库收集/","excerpt":"","text":"SmartCropper A library for cropping image in a smart way that can identify the border and correct the cropped image. 智能图片裁剪框架。自动识别边框，手动调节选区，使用透视变换裁剪并矫正选区；适用于身份证，名片，文档等照片的裁剪 SmartScannerSmartCamera 是一个 Android 相机拓展库，提供了一个高度可定制的实时扫描模块能够实时采集并且识别相机内物体边框是否吻合指定区域 AndroidPhotoFiltersPhotoFiltersSDK aims to provide fast, powerful and flexible image processing instrument for creating awesome effects on any image media. CainCamera CainCamera是一个美颜类相机，主要用于学习如何实现实时美颜、滤镜、贴纸、拍照、短视频分段录制、回删等美颜类相机预览拍照相关功能，目前动态贴纸美型美妆仍在开发当中","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]},{"title":"Flutter 开源APP收集","slug":"基于Flutter的开源项目","date":"2018-09-01T19:19:45.000Z","updated":"2018-09-02T07:19:49.364Z","comments":true,"path":"2018/09/02/基于Flutter的开源项目/","link":"","permalink":"http://yoursite.com/2018/09/02/基于Flutter的开源项目/","excerpt":"","text":"基于Flutter的开源项目和GankFlutter干货集中营 客户端 flutter版","categories":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/categories/flutter/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"},{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/tags/flutter/"}],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://yoursite.com/categories/flutter/"}]},{"title":"Android 开源APP收集","slug":"android-开源APP收集","date":"2018-08-29T10:56:45.000Z","updated":"2018-09-05T07:43:15.194Z","comments":true,"path":"2018/08/29/android-开源APP收集/","link":"","permalink":"http://yoursite.com/2018/08/29/android-开源APP收集/","excerpt":"","text":"LeafPic ( Github | APK | 适用于: 初级开发者)LeafPic 是最好的开源图库APP，非常适合初级开发者学习，库中实现了动态主题的功能，可以好好研读一下啊 Simple Calendar (Github | APK | 适用于：初级开发者)这个应用完全基于 Kotlin 来开发的，如果你正在或打算学习 Kotlin 的话，这个项目是一个很好的应用，通过这个项目你还可以学习到定制Widget的方法 Amaze File Manager (Github | APK | 适用于：中级开发者)文件管理器应该是现在手机的标配了，通过这个项目你可以学习到如何处理手机上sdcard中的文件 Easy Sound Recorder (Github | APK | 适用于：初级开发者)通过这个项目你可以学习到关于Android平台录音的相关的信息，这个应用本省比较简单(只有一个主Activity)，这个应用是按照Material Design来设计的 MLManager (Github | APK | 适用于：初级开发者)通过这个项目学习到关于Android中安装应用的详细信息，以及安装卸载应用等相关的知识 PhotoAffix (Github | APK | 适用于：初级开发者)通过这个项目可以学习到Android开发相关的基础知识，能够进一步巩固自己的基础知识，学到关于定制View的相关的知识 MovieGuide (Github | APK | 适用于：中级开发者)这个项目使用了一些框架，想MVP，Clean Architecture， RxJava， Dagger2，可以更好的学习这个框架的使用情况 AnExplorer (Github | APK | 适用于：中级开发者)是一个文件管理器，兼容平板和手机，学习到文件处理，root管理，定制views等知识 Minimal ToDo (Github | APK | 适用于：初级开发者)学习Android相关的基础知识 Timber (Github | APK | 适用于：高级开发者)Timber是一个设计美观，功能丰富的音乐播放器，这个项目不太适合初级开发者，涉及到的内容比较多 AnotherMonitor (Github | APK | 适用于：中级开发者)监控Android的进程，内存使用，CPU使用情况等，工程简单易懂 InstaMaterial (Github | APK | 适用于：初级开发者)这个工程师学习Material Design的好项目，有大量的Material Design的元素、动画，可以在自己的应用中参考实现 CoCoin (Github | APK | 适用于：初级开发者)是一个个人视图记账的应用，有漂亮的UI设计，可以学习到处理数据，使用图表，定制View等 OmniNotes (Github | APK | 适用于：中级开发者)是像Evernote的一款笔记应用，还有大量的特性：分享，搜索，附件，视频，音频，时间提醒等功能 Clip Stack (Github | APK | 适用于：初级开发者)是管理复制粘贴管理的应用，可以了解到包的结构，应用架构，编码规范等知识，这个项目已经停止更新了 Super Clean Master (Github | APK | 适用于：高级开发者)和Clean master 功能类似的应用，用更简洁优雅的方式实现了相关的功能 Travel Mate (Github | APK | 适用于：中级开发者)是一款基于地理位置和地图的旅游应用 KISS (Github | APK | 适用于：中级开发者)轻量级的launcher,特点是简单，快速 Turbo Editor (Github | APK | 适用于：中级开发者)非常强大的文字编辑器，对不同的语言支持语法高亮，还可以打开大文件 Wally (Github | APK | 适用于：初级开发者)简单，快速，高效的壁纸应用，这个莹莹易于扩展和维护 Pedometer (Github | APK | 适用于：初级开发者)是一款计步软件，可以学习到传感器的相关知识 Antoxp2p 聊天软件 MusicDNAA Music Player for android that renders beautiful DNA(Visualization) of the currently playing music. Jams Music Player Launcher-mxKnowWeather 收藏美观、实用的天气app,基于谷歌最新的 Android Architecture Components架构和微信Android模块化架构重构实践对项目进行了重构 实践Hub在项目中的使用 Minimal-TodoA fully Material ToDo app with minimal features, just enough to be useful.WeatherAlarmClock 天气闹钟是一款具有天气提醒功能的闹钟，灵感来自于出门前经常忘记看天气预报没有带伞而淋雨的尴尬情况。主要功能：闹钟、天气预报、计时器、录音、城市管理、城市搜索、自动定位、主题切换、扫描二维码，创造二维码、清除缓存、一键清理等。BookReader“任阅” 网络小说阅读器，3D翻页效果、txt/pdf/epub书籍阅读、Wifi传书~","categories":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"}],"keywords":[{"name":"android","slug":"android","permalink":"http://yoursite.com/categories/android/"}]},{"title":"","slug":"Android-开源基础组件","date":"2018-08-29T01:48:00.000Z","updated":"2018-08-29T01:49:09.000Z","comments":true,"path":"2018/08/29/Android-开源基础组件/","link":"","permalink":"http://yoursite.com/2018/08/29/Android-开源基础组件/","excerpt":"","text":"Epoxy Epoxy is an Android library for building complex screens in a RecyclerView https://goo.gl/eIK82p","categories":[],"tags":[],"keywords":[]},{"title":"kotlin 基础知识","slug":"kotlin-基础知识","date":"2018-08-25T16:08:45.000Z","updated":"2018-09-05T06:27:41.108Z","comments":true,"path":"2018/08/26/kotlin-基础知识/","link":"","permalink":"http://yoursite.com/2018/08/26/kotlin-基础知识/","excerpt":"","text":"kotlin 基础知识中文官方 kotlin官方sample 介绍基础语法（一）123456789101112fun getGreeting(): String &#123; val words = mutableListOf&lt;String&gt;() words.add(\"Hello,\") words.add(\"world!\") return words.joinToString(separator = \" \")&#125;fun main(args: Array&lt;String&gt;) &#123; println(getGreeting())&#125;输出：hello world for 循环1234567891011121314151617fun testFor()&#123; val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (item in items) &#123; println(item) &#125; for (index in items.indices)&#123; print(\"index is $index value is $&#123;items[index]&#125; \\n\") &#125;&#125;输出：applebananakiwifruitindex is 0 value is apple index is 1 value is banana index is 2 value is kiwifruit while 循环12345678910111213fun testWhile()&#123; val items = listOf(\"apple\", \"banana\", \"kiwifruit\") var index = 0 while ( index &lt; items.size)&#123; println(\"items is $&#123;items[index]&#125;\") index++ &#125;&#125;结果：items is appleitems is bananaitems is kiwifruit When 表达式 (java的switch)123456789fun testWhen( a : Int)&#123; when(a)&#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") 4 -&gt; println(\"x == 4\") in 5..10 -&gt; println(\"x in 5 ..10\") !in 100..200 -&gt; println(\"x !in 100..200\") else -&gt; print(\"otherwise\") &#125;&#125; 使用区间（range）123456789101112131415161718192021222324fun testRange()&#123; var i = 4 if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i) &#125; for (i in 1..4) print(i) println() for (i in 4 downTo 1) print(i) println() for (i in 1..10 step 2) print(i) println() for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 print(i) &#125;&#125;结果：41234432113579123456789 Maps 遍历12345678fun testMap()&#123; var maps = mutableMapOf&lt;String,String&gt;(); maps.put(\"key1\",\"value1\") maps.put(\"key2\",\"value2\") for ((k, v) in maps) &#123; println(\"$k -&gt; $v\") &#125;&#125; 空安全123456789101112131415161718192021222324252627282930/** * 空安全 */fun testNull()&#123; // 编译错误，编译不通过，s 不能为空，// var s : String = \"abc\"// s = null // 便通过，s1 可以为空// var s1 : String? = \"abc\"// s1 = null// // 还是编译不通过，s1为空// print(s1.length) // 安全调用，b?.length 返回Null ,不会出异常// val a = \"Kotlin\"// val b: String? = null// println(b?.length)// println(a?.length) // !! 操作符 非空断言运算符 kotlin.KotlinNullPointerException var b : String? = null val l = b!!.length var data = 3 //当data不为空的时候，执行语句块 data?.let&#123; println(\"data is not null\") &#125;&#125; Elvis 操作符1234567val l: Int = if (b != null) b.length else -1// 应用 ?: 表达式之后val l = b?.length ?: -1如果 ?: 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。 ####高阶函数与 lambda 表达式 基本类型1234567Type Bit widthDouble 64Float 32Long 64Int 32Short 16Byte 8 ###函数 1234567891011121314151617181920212223242526272829303132函数的声明：fun say(str: String): String &#123; return str&#125;简写：fun say(str: String): String = str在简化：fun say(str: String): str函数的默认参数：fun say(firstName: String = \"Tao\", lastName: String = \"Zhang\")&#123;&#125;变参函数：//在Java中，我们这么表示一个变长函数public boolean hasEmpty(String... strArray)&#123; for (String str : strArray)&#123; if (\"\".equals(str) || str == null) return true; &#125; return false;&#125;//在Kotlin中，使用关键字vararg来表示fun hasEmpty(vararg strArray: String?): Boolean&#123; for (str in strArray)&#123; if (\"\".equals(str) || str == null) return true &#125; return false&#125; 嵌套函数Kotlin 的函数有一些非常有意思的特性，比如函数中再声明函数。与内部类有些类似，内部函数可以直接访问外部函数的局部变量、常量，而外部函数同级的其他函数不能访问到内部函数。这种写法通常使用在 会在某些条件下触发递归的方法内或者是不希望外部其他函数访问到的函数，在一般情况下是不推荐使用嵌套函数的 1234567891011fun function() &#123; val str = \"hello!\" fun say(count: Int = 10) &#123; println(str) if (count &gt; 0) &#123; say(count - 1) &#125; &#125; say()&#125; 类构造函数 Kotlin 的构造函数可以写在类头中，跟在类名后面，如果有注解还需要加上关键字constructor。这种写法声明的构造函数，我们称之为主构造函数。例如下面我们为Person创建带一个String类型参数的构造函数。在构造函数中声明的参数，它们默认属于类的公有字段，可以直接使用，如果你不希望别的类访问到这个变量，可以用private修饰。在主构造函数中不能有任何代码实现，如果有额外的代码需要在构造方法中执行，你需要放到init代码块中执行。同时，在本示例中由于需要更改 name 参数的值，我们将 val 改为 var,表明 name 参数是一个可改变的参数。 123456789101112131415161718192021222324252627open class Person (private var name : String)&#123; private var description = \"\"; init &#123; name = \"zlz\" println(\"init $name\") &#125; constructor( name : String , des : String) : this(name) &#123; this.description = des println(\"constructor $name\") &#125; fun sayHello()&#123; println(\"sayHello name is $name , description is $description\") &#125; var person = Person(\"hello\",\"xiaoqiang\") person.sayHello() 结果： init zlz constructor hello sayHello name is zlz , description is xiaoqiang&#125; 次级构造函数 一个类当然会有多个构造函数的可能，只有主构造函数可以写在类头中，其他的次级构造函数(Secondary Constructors)就需要写在类体中了。次级构造函数调用了主构造函数，完成 name 的赋值。由于次级构造函数不能直接将参数转换为字段，所以需要手动声明一个 description 字段，并为 description 字段赋值。 修饰符123456open 修饰符Kotlin 默认会为每个变量和方法添加 final 修饰符。这么做的目的是为了程序运行的性能，其实在 Java 程序中，你也应该尽可能为每个类添加final 为每个类加了final也就是说，在 Kotlin 中默认每个类都是不可被继承的。如果你确定这个类是会被继承的，那么你需要给这个类添加 open 修饰符。internal 修饰符Java 有三种访问修饰符，public/private/protected，还有一个默认的包级别访问权限没有修饰符。在 Kotlin 中，默认的访问权限是 public，也就是说不加访问权限修饰符的就是 public 的。而多增加了一种访问修饰符叫 internal。它是模块级别的访问权限。何为模块(module)，我们称被一起编译的一系列 Kotlin 文件为一个模块。在 IDEA 中可以很明确的看到一个 module 就是一个模块，当跨 module 的时候就无法访问另一个module 的 internal 变量或方法 枚举类Kotlin 与 Java 混编Java 转换为 KotlinIntellij IDEA 会帮你一键转换，将 Java 代码转换成 Kotlin 代码(但是反过来就不行了)。在 Mac 上，系统默认的快捷键为control+shift+command+K,快捷键可以通过你的编译器 keymap 中修改：command+, -&gt; 搜索keymap -&gt; 右侧搜索kotlin，可以查看到Convert Java File to Kotlin File项。 在 Kotlin 中调用 Java 代码1234567891011fun invokeJava(source: List&lt;Int&gt;)&#123; var calendar = Calendar.getInstance(); if (calendar.firstDayOfWeek == Calendar.SUNDAY) &#123; // 调用 getFirstDayOfWeek() calendar.firstDayOfWeek = Calendar.MONDAY // 调用ll setFirstDayOfWeek() &#125; if (!calendar.isLenient) &#123; // 调用 isLenient() calendar.isLenient = true // 调用 setLenient() &#125; &#125; Calendar.getInstance() 是Java中的类 返回 void 的方法 如果一个 Java 方法返回 void，那么从 Kotlin 调用时中返回 Unit。 万一有人使用其返回值，它将由 Kotlin 编译器在调用处赋值， 因为该值本身是预先知道的（是 Unit） #####将 Kotlin 中是关键字的 Java 标识符进行转义一些 Kotlin 关键字在 Java 中是有效标识符：in、 object、 is 等等。 如果一个 Java 库使用了 Kotlin 关键字作为方法，你仍然可以通过反引号（`）字符转义它来调用该方法： 123456789// Java 代码中有个方法叫 is()public void is()&#123; //...&#125;// 转换为 Kotlin 代码需要加反引号转义fun `is`() &#123; //...&#125; static 方法 在 Kotlin 中没有 static关键字,那么如果在 Java 代码中想要通过类名调用一个 Kotlin 类的方法，你需要给这个方法加入@JvmStatic注解（这个注解只在 jvm 平台有用）companion object表示外部类的一个伴生对象，你可以把他理解为外部类自动创建了一个对象作为自己的field 1234567891011121314151617写法一object StringUtils&#123; @JvmStatic fun isEmpty ( str : String) : Boolean&#123; return \"\"==str &#125;&#125;写法二class StringUtils &#123; companion object &#123; fun isEmpty(str: String): Boolean &#123; return \"\" == str &#125; &#125;&#125;StringUtils.isEmpty(\"hello\");StringUtils.Companion.isEmpty(\"hello\"); Java 中调用 Kotlin####委托","categories":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/categories/kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}],"keywords":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/categories/kotlin/"}]},{"title":"Bugly热补丁发布和使用","slug":"bugly热补丁发布流程","date":"2018-08-15T16:08:45.000Z","updated":"2018-08-29T00:05:48.000Z","comments":true,"path":"2018/08/16/bugly热补丁发布流程/","link":"","permalink":"http://yoursite.com/2018/08/16/bugly热补丁发布流程/","excerpt":"","text":"Bugly热补丁发布和使用精进课堂热补丁集成的bugly版本的热更新，bugly 则使用的是简化版本的tinker 。 bulgy 热补丁接入文档 tinker接入文档 打全渠道包通常我们执行gradle脚本 assembleReleaseChannels 命令打全渠道包，打包之前需要校验，versionName versionCode是否正确，目前tinkerId是和版本号绑定的也就是versionName, 比如，1.8.0版本，那么tinkerId也是1.8.0，tinkerId在 app/tinker-support.gradle 脚本中 tinkerId=globalConfig.getAt(“appVersionName”) 获取 上面生成的是按照时间来生成的基准包。 生成补丁包 首先修改tinker-support.gradle 脚本文件的baseApkDir ，改成我们刚才生成的bakApk日期 在AboutUsActivity 修改代码 执行生成热补丁脚本命令buildTinkerPatchRelease 命令生成补丁，补丁生成成功如下图 patch_signed_7zip.apk 是生成之后成功的经过7z压缩的补丁。 补丁生成之后随即选择一个渠道包进行安装，然后补丁包上床bugly 的热补丁发布平台上，进性测试发布，如果该版本目前没有线上用户，则可选择全量进行测试。 选择发布之后，启动之前安装的渠道包，在logcat中用tinker做关键字过滤，查看日志 这表示补丁已经下发成功到客户端，并且补丁本地合成成功，等待重启进程，退出应用或是关闭屏幕在开启，则会自动重启进程。 补丁合成成功。 本地安装补丁 在AboutUsActivity中initData 方法，有对本地SDCARD 上面的patch_signed_7zip.apk 补丁文件进行加载，测试补丁是否正确，只需要把生成好的补丁文件放到SDCARD 的根目录上面，然后打开关于页面，日志中看logcat 的tinker标签的日志来判断是否补丁成功。 12345 String path = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\";// File file = new File(path);// if(file.exists()) &#123;// Beta.applyTinkerPatch(getApplicationContext(), path);// &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"热补丁","slug":"热补丁","permalink":"http://yoursite.com/tags/热补丁/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RxJava2.0 中的背压","slug":"RxJava-背压","date":"2018-07-21T10:56:45.000Z","updated":"2018-07-21T14:06:20.000Z","comments":false,"path":"2018/07/21/RxJava-背压/","link":"","permalink":"http://yoursite.com/2018/07/21/RxJava-背压/","excerpt":"","text":"背压 backpressure 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略，或者说背压是流速控制的一种策略Backpressure 其实是一种现象：在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。 背压策略的一个前提是异步环境，也就是说，被观察者和观察者处在不同的线程环境中。 背压（Backpressure）并不是一个像flatMap一样可以在程序中直接使用的操作符，他只是一种控制事件流速的策略。 响应式拉取（reactive pull） 在RxJava的观察者模型中，被观察者是主动的推送数据给观察者，观察者是被动接收的。而响应式拉取则反过来，观察者主动从被观察者那里去拉取数据，而被观察者变成被动的等待通知再发送数据。 观察者可以根据自身实际情况按需拉取数据，而不是被动接收（也就相当于告诉上游观察者把速度慢下来），最终实现了上游被观察者发送事件的速度的控制，实现了背压的策略 RxJava 2.x 更新中，出现了两种观察者模式： Observable ( 被观察者 ) / Observer ( 观察者 ) Flowable （被观察者）/ Subscriber （观察者 RxJava 2.x 也为我们保留了简化订阅方法，我们可以根据需求，进行相应的简化订阅，只不过传入对象改为了 ConsumerConsumer 即消费者，用于接收单个值，BiConsumer 则是接收两个值. Hot and Cold ObservablesHot Observables 和cold Observables并不是严格的概念区分，它只是对于两类Observable形象的描述 Cold Observables：指的是那些在订阅之后才开始发送事件的Observable（每个Subscriber都能接收到完整的事件）。 Hot Observables:指的是那些在创建了Observable之后，（不管是否订阅）就开始发送事件的Observable 在1.0中我们一般使用的都是Cold Observable，除非特殊需求，才会使用Hot Observable,在这里，Hot Observable这一类是不支持背压的，而是Cold Observable这一类中也有一部分并不支持背压（比如interval，timer等操作符创建的Observable），都是Observable，结果有的支持背压，有的不支持，这就是RxJava1.X的一个问题，但在2.0中，这种问题已经解决了 背压例子以两根水管举例子: 之前我们所的上游和下游分别是Observable和Observer, 这次不一样的是上游变成了Flowable, 下游变成了Subscriber, 但是水管之间的连接还是通过subscribe(), 我们来看看最基本的用法吧: Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); } }, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); s.request(Long.MAX_VALUE); //注意这句代码 } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }; upstream.subscribe(downstream); 这段代码中,分别创建了一个上游Flowable和下游Subscriber, 上下游工作在同一个线程中, 执行结果： 07-20 16:30:29.642 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe 07-20 16:30:29.643 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 1 onNext: 1 07-20 16:30:29.644 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 2 onNext: 2 emit 3 onNext: 3 emit complete 07-20 16:30:29.645 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onComplete 在上面的代码中也有这么一句代码: s.request(Long.MAX_VALUE); 这句代码有什么用呢, 不要它可以吗? 我们来试试: 去掉这句这行结果： 07-20 16:35:47.474 12931-12931/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe 07-20 16:35:47.475 12931-12931/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 1 07-20 16:35:47.487 12931-12931/com.nanchen.rxjava2examples W/RxCaseBackPressActivity: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377) at com.nanchen.rxjava2examples.module.backpress.RxCaseBackPressActivity$1.subscribe(RxCaseBackPressActivity.java:194) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) at io.reactivex.Flowable.subscribe(Flowable.java:12986) at io.reactivex.Flowable.subscribe(Flowable.java:12935) at com.nanchen.rxjava2examples.module.backpress.RxCaseBackPressActivity.doSomething(RxCaseBackPressActivity.java:230) at com.nanchen.rxjava2examples.module.rxjava2.operators.item.RxOperatorBaseActivity.onViewClicked(RxOperatorBaseActivity.java:47) at com.nanchen.rxjava2examples.module.rxjava2.operators.item.RxOperatorBaseActivity_ViewBinding$1.doClick(RxOperatorBaseActivity_ViewBinding.java:38) at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22) at android.view.View.performClick(View.java:6303) at android.view.View$PerformClick.run(View.java:24828) at android.os.Handler.handleCallback(Handler.java:789) at android.os.Handler.dispatchMessage(Handler.java:98) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6798) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 07-20 16:35:47.487 12931-12931/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 2 emit 3 emit complete 刚刚发出了第一个请求，就抛出异常了， 为什么呢？首先第一个同步的代码, 为什么上游发送第一个事件后下游就抛出了MissingBackpressureException异常, 这是因为下游没有调用request, 上游就认为下游没有处理事件的能力, 而这又是一个同步的订阅, 既然下游处理不了, 那上游不可能一直等待吧, 如果是这样, 万一这两根水管工作在主线程里, 界面不就卡死了吗, 因此只能抛个异常来提醒我们 。 那异步线程会报错误么？ Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); } }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); 执行结果： 07-20 16:47:32.549 22878-22878/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe emit 1 07-20 16:47:32.550 22878-22878/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 2 emit 3 emit complete 没有报异常，因为是异步，那么s.request(Long.MAX_VALUE); 什么意思呢，其实Flowable在设计的时候采用了一种新的思路也就是响应式拉取的方式来更好的解决上下游流速不均衡的问题，requeset 标识的是下游的处理能力， 下游能处理几个就告诉上游我要几个, 这样只要上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM. 异步线程中上游正确发送了所有事件？ 这是因为在Flowable里默认有一个大小为128的水缸, 当上下游工作在不同的线程中时, 上游就会先把事件发送到这个水缸中, 因此, 下游虽然没有调用request, 但是上游在水缸中保存着这些事件, 只有当下游调用request时, 才从水缸里取出事件发给下游. 验证一下: public static void request(long n) { mSubscription.request(n); //在外部调用request请求上游 } public static void demo3() { Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); } }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; //把Subscription保存起来 } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); } 在界面上增加了一个按钮, 点击一次就调用Subscription.request(1), 来看看运行结果: 上游的缓冲池有多大？ 答案是128 在Flowable源码里面可以找到 public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt; { /** The default buffer size. */ static final int BUFFER_SIZE; static { BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128)); } 测试一下： Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; i &lt; 128; i++) { Log.d(TAG, &quot;emit &quot; + i); emitter.onNext(i); } } }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); 执行结果： zlc.season.rxjava2demo D/TAG: onSubscribe zlc.season.rxjava2demo D/TAG: emit 0 ... zlc.season.rxjava2demo D/TAG: emit 126 zlc.season.rxjava2demo D/TAG: emit 127 zlc.season.rxjava2demo D/TAG: emit 128 //这是第129个事件 zlc.season.rxjava2demo W/TAG: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377) at zlc.season.rxjava2demo.demo.ChapterSeven$7.subscribe(ChapterSeven.java:169) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) at io.reactivex.Flowable.subscribe(Flowable.java:12218) at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761) 当缓冲池里面的内容大于128的时候一样的报异常，这时候就需要一个更大池子了，BackpressureStrategy.BUFFER这个策略下，这个池子没有上线，可以一直发，直到内存爆掉，不信看例子： Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; i &lt; 1000; i++) { Log.d(TAG, &quot;emit &quot; + i); emitter.onNext(i); } } }, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); 运行结果： zlc.season.rxjava2demo D/TAG: onSubscribe zlc.season.rxjava2demo D/TAG: emit 0 zlc.season.rxjava2demo D/TAG: emit 1 zlc.season.rxjava2demo D/TAG: emit 2 ... zlc.season.rxjava2demo D/TAG: emit 997 zlc.season.rxjava2demo D/TAG: emit 998 zlc.season.rxjava2demo D/TAG: emit 999 如果放开数量限制，无线次发送事件，最终会导致内存暴增直到爆掉，所以Flowable用不好就内存泄漏啦 BackpressureStrategy.DROP 策略Drop就是直接把存不下的事件丢弃 public static void request() { mSubscription.request(128); } public static void demo3() { Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; ; i++) { emitter.onNext(i); } } }, BackpressureStrategy.DROP).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); } 执行结果： FLowable内部的默认的水缸大小为128, 因此, 它刚开始肯定会把0-127这128个事件保存起来, 然后丢弃掉其余的事件, 当我们request(128)的时候,下游便会处理掉这128个事件, 那么上游水缸中又会重新装进新的128个事件 BackpressureStrategy.LATESTLatest就是只保留最新的事件. Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; i &lt; 10000; i++) { //只发1w个事件 emitter.onNext(i); } } }, BackpressureStrategy.DROP).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; s.request(128); //一开始就处理掉128个事件 } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); Latest的运行结果 从运行结果中可以看到, 除去前面128个事件, 与Drop不同, Latest总是能获取到最后最新的事件, 例如这里我们总是能获得最后一个事件9999. 关于FLowable的策略我们也讲完了, 这些FLowable是我自己创建的, 所以我可以选择策略, 那面对有些FLowable并不是我自己创建的, 该怎么办呢? 比如RxJava中的interval操作符, 这个操作符并不是我们自己创建的, 来看下面这个例子 Flowable.interval(1, TimeUnit.MICROSECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Long&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); s.request(Long.MAX_VALUE); } @Override public void onNext(Long aLong) { Log.d(TAG, &quot;onNext: &quot; + aLong); try { Thread.sleep(1000); //延时1秒 } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); interval操作符发送Long型的事件, 从0开始, 每隔指定的时间就把数字加1并发送出来, 在这个例子里, 我们让它每隔1毫秒就发送一次事件, 在下游延时1秒去接收处理, 不用猜也知道结果是什么: 07-20 17:29:12.547 13561-13561/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe 07-20 17:29:12.568 13561-13561/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onNext: 0 07-20 17:29:13.577 13561-13561/com.nanchen.rxjava2examples W/RxCaseBackPressActivity: onError: io.reactivex.exceptions.MissingBackpressureException: Can&apos;t deliver value 128 due to lack of requests at io.reactivex.internal.operators.flowable.FlowableInterval$IntervalSubscriber.run(FlowableInterval.java:87) at io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:39) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:457) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:307) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:302) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636) at java.lang.Thread.run(Thread.java:764) 07-20 17:29:13.578 13561-13561/com.nanchen.rxjava2examples I/Choreographer: Skipped 61 frames! The application may be doing too much work on its main thread. 错误信息比较明显，缓冲池子超过了128 了，不能deliver了，呵呵，其实RxJava给我们提供了其他的方法，策略和上面的一样 onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest()","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]},{"title":"Android Handler消息机制源码解析（面试问题）","slug":"Android-Handler-消息机制源码解析","date":"2018-07-21T10:56:45.000Z","updated":"2018-07-31T02:50:31.000Z","comments":false,"path":"2018/07/21/Android-Handler-消息机制源码解析/","link":"","permalink":"http://yoursite.com/2018/07/21/Android-Handler-消息机制源码解析/","excerpt":"","text":"做Android的，应该都用过handler，handler是异步通信用的，用来解决耗时任务阻塞主线程的，耗时任务放到子线程去做，通过handler进行UI更新,handler 涉及 Message,MessageQueue,Looper ,如下图： MessageQueue","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]},{"title":"RxJava基本使用","slug":"RxJava基本使用","date":"2018-07-16T10:56:45.000Z","updated":"2018-07-20T14:50:07.000Z","comments":true,"path":"2018/07/16/RxJava基本使用/","link":"","permalink":"http://yoursite.com/2018/07/16/RxJava基本使用/","excerpt":"","text":"优秀的人，不是不合群，而是他们合群的人里面没有你 RxJava是什么?开源地址 RxAndroid 要知道RxJava是什么，那么你应该先去了解一下Rx。Rx的全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。Rx已经渗透到了各个语言中，有了Rx所以才有了 RxJava，Rx.NET、RxJS、RxSwift、Rx.rb、RxPHP等等 官方描述 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库） RXJava 是基于观察者模式构建的 我们先把观察者模式说清楚 例如：“按下开关，台灯灯亮” 在这个事件中，台灯作为观察者，开关作为被观察者，台灯透过电线来观察开关的状态来并做出相应的处理 开关（被观察者）作为事件的产生方（生产“开”和“关”这两个事件），是主动的，是整个开灯事理流程的起点。 台灯（观察者）作为事件的处理方（处理“灯亮”和“灯灭”这两个事件），是被动的，是整个开灯事件流程的终点。 在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的（上图没有体现，后面对会讲到）。 响应式编程是什么？ 响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。 RxJava好在哪？例如：从服务器上拉去最新小区列表的需求，可能这样写：12345678910111213141516171819202122new Thread() &#123; @Override public void run() &#123; super.run(); //从服务端获取小区列表 List&lt;Community&gt; communities = getCommunitiesFromServer(); for (Community community : communities) &#123; List&lt;House&gt; houses = community.houses; for (House house : houses) &#123; if (house.price &gt;= 5000000) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); &#125; &#125; &#125; &#125; &#125;.start(); RxJava 这样写：1234567891011121314151617181920Observable.from(getCommunitiesFromServer()) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.houses); &#125; &#125;).filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.price&gt;=5000000; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); Lambda 简化：12345Observable.from(getCommunitiesFromServer()) .flatMap(community -&gt; Observable.from(community.houses)) .filter(house -&gt; house.price&gt;=5000000).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::addHouseInformationToScreen); RxJava基本元素RxJava基本使用操作符Create create 操作符应该是最常见的操作符了，主要用于产生一个 Obserable 被观察者对象，为了方便大家的认知，以后的教程中统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e(TAG, \"Observable emit 1\" + \"\\n\"); e.onNext(1); Log.e(TAG, \"Observable emit 2\" + \"\\n\"); e.onNext(2); Log.e(TAG, \"Observable emit 3\" + \"\\n\"); e.onNext(3); e.onComplete(); Log.e(TAG, \"Observable emit 4\" + \"\\n\" ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.e(TAG, \"onSubscribe : \" + d.isDisposed() + \"\\n\" ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; Log.e(TAG, \"onNext : value : \" + integer + \"\\n\" ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); Log.e(TAG, \"onNext : isDisposable : \" + mDisposable.isDisposed() + \"\\n\"); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.e(TAG, \"onError : value : \" + e.getMessage() + \"\\n\" ); &#125; @Override public void onComplete() &#123; Log.e(TAG, \"onComplete\" + \"\\n\" ); &#125; &#125;); 结果： 12345678onSubscribe : falseObservable emit 1onNext : value : 1Observable emit 2onNext : value : 2onNext : isDisposable : trueObservable emit 3Observable emit 4 Map 它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return \"This is result \" + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"accept : \" + s +\"\\n\"); Log.e(TAG, \"accept : \" + s +\"\\n\" ); &#125; &#125;); 结果： 12307-10 14:15:49.857 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 107-10 14:15:49.859 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 207-10 14:15:49.861 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 3 Concat简单来说就是连接两个或多个发射器，向一个发射器一样，他们不产生交叉 Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;concat : &quot;+ integer + &quot;\\n&quot; ); } }); 执行结果： 07-10 14:24:10.147 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 1 07-10 14:24:10.150 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 2 07-10 14:24:10.154 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 3 07-10 14:24:10.158 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 4 07-10 14:24:10.162 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 5 07-10 14:24:10.166 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 6 FlatMap transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); } }); 结果： ConcatMap concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证吧 Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); } }); 执行结果： Distinct顾名思义，去重操作符 Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\\n&quot;); } }); 执行结果： Filter emit only those items from an Observable that pass a predicate test Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() { @Override public boolean test(@NonNull Integer integer) throws Exception { return integer &gt;= 10; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;filter : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;filter : &quot; + integer + &quot;\\n&quot;); } }); 结果： just就是一个简单的发射器依次调用 onNext() 方法。 Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { mRxOperatorsText.append(&quot;accept : onNext : &quot; + s + &quot;\\n&quot;); Log.e(TAG,&quot;accept : onNext : &quot; + s + &quot;\\n&quot; ); } }); 结果： buffer periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a timebuffer 操作符接受两个参数，buffer(count,skip)，作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。 Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() { @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception { mRxOperatorsText.append(&quot;buffer size : &quot; + integers.size() + &quot;\\n&quot;); Log.e(TAG, &quot;buffer size : &quot; + integers.size() + &quot;\\n&quot;); mRxOperatorsText.append(&quot;buffer value : &quot;); Log.e(TAG, &quot;buffer value : &quot; ); for (Integer i : integers) { mRxOperatorsText.append(i + &quot;&quot;); Log.e(TAG, i + &quot;&quot;); } mRxOperatorsText.append(&quot;\\n&quot;); Log.e(TAG, &quot;\\n&quot;); } }); 结果： timer create an Observable that emits a particular item after a given delay Log.e(TAG, &quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); } }); 输出： Interval create an Observable that emits a sequence of integers spaced by a given time interval Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); } }); 输出： skip suppress the first n items emitted by an Observable 代表跳过 count 个数目开始接收。 Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;skip : &quot;+integer + &quot;\\n&quot;); Log.e(TAG, &quot;skip : &quot;+integer + &quot;\\n&quot;); } }); 结果： take emit only the first n items emitted by an Observable 接受一个 long 型参数 count ，代表至多接收 count 个数据 Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;take : &quot;+integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: take : &quot;+integer + &quot;\\n&quot; ); } }); 结果： Debounce only emit an item from an Observable if a particular timespan has passed without it emitting another item Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception { // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); } }).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;debounce :&quot; + integer + &quot;\\n&quot;); Log.e(TAG,&quot;debounce :&quot; + integer + &quot;\\n&quot;); } }); 结果： last emit only the last item (or the last item that meets some condition) emitted by an Observable last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 Observable.just(1, 2, 3) .last(4) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;last : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;last : &quot; + integer + &quot;\\n&quot;); } }); 结果： merge combine multiple Observables into one by merging their emissions merge 顾名思义，熟悉版本控制工具的你一定不会不知道 merge 命令，而在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。 Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;merge :&quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: merge :&quot; + integer + &quot;\\n&quot; ); } }); 结果： reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;reduce : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: reduce : &quot; + integer + &quot;\\n&quot;); } }); 结果： scan apply a function to each item emitted by an Observable, sequentially, and emit each successive value scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;scan &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: scan &quot; + integer + &quot;\\n&quot;); } }); 结果： zip combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/&quot;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()).build(); LolInterface lolInterfaceRequest = retrofit.create(LolInterface.class); Observable&lt;LolDataList&gt; observable1 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable&lt;LolDataList&gt; observable2 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;LolDataList, LolDataList, String&gt;() { @Override public String apply(@NonNull LolDataList lolDataList, @NonNull LolDataList lolDataList2) throws Exception { return &quot;合并后的数据为 lolDataList1=&quot;+lolDataList.getData().get(0).getDisplayName() + &quot;,lolDataList2=&quot;+lolDataList2.getData().get(0).getDisplayName(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;accept: 成功：&quot; + s+&quot;\\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;accept: 失败：&quot; + throwable+&quot;\\n&quot;); } }); 结果： accept: 成功：合并后的数据为 lolDataList1=灭世魔神 诺提勒斯,lolDataList2=灭世魔神 诺提勒斯 subScribeOn 指定的就是发射事件的线程 多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略 observeOn 指定的就是订阅者接收事件的线程。 多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次 线程切换Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); e.onNext(1); e.onComplete(); } }).subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(mainThread)，Current thread is &quot; + Thread.currentThread().getName()); } }) .observeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(io)，Current thread is &quot; + Thread.currentThread().getName()); } }); 结果： 07-14 11:43:11.669 8550-8611/com.nanchen.rxjava2examples E/RxThreadActivity: Observable thread is : RxNewThreadScheduler-1 07-14 11:43:11.670 8550-8550/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(mainThread)，Current thread is main 07-14 11:43:11.671 8550-8612/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(io)，Current thread is RxCachedThreadScheduler-2 场景举例 一个简单的网络请求 Observable.create(new ObservableOnSubscribe&lt;Response&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Response&gt; e) throws Exception { Builder builder = new Builder() .url(&quot;http://api.avatardata.cn/MobilePlace/LookUp?key=ec47b85086be4dc8b5d941f5abd37a4e&amp;mobileNumber=13021671512&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); Response response = call.execute(); e.onNext(response); Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); } }).map(new Function&lt;Response, MobileAddress&gt;() { @Override public MobileAddress apply(@NonNull Response response) throws Exception { Log.e(TAG, &quot;map 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { Log.e(TAG, &quot;map:转换前:&quot; + response.body()); return new Gson().fromJson(body.string(), MobileAddress.class); } } return null; } }).observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress s) throws Exception { Log.e(TAG, &quot;doOnNext 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Log.e(TAG, &quot;doOnNext: 保存成功：&quot; + s.toString() + &quot;\\n&quot;); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress data) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Log.e(TAG, &quot;成功:&quot; + data.toString() + &quot;\\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Log.e(TAG, &quot;失败：&quot; + throwable.getMessage() + &quot;\\n&quot;); } }); 执行结果： 07-13 09:13:08.664 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: map 线程:RxCachedThreadScheduler-1 map:转换前:okhttp3.internal.http.RealResponseBody@3e17a0f 07-13 09:13:08.691 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: create 线程:RxCachedThreadScheduler-1 07-13 09:13:08.691 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext 线程:main 07-13 09:13:08.702 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext: 保存成功：MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 07-13 09:13:08.737 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: subscribe 线程:main 07-13 09:13:08.741 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: 成功:MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 多个网络请求串行执行Observable.create(new ObservableOnSubscribe&lt;LolDataList&gt;() { @Override public void subscribe(ObservableEmitter&lt;LolDataList&gt; e) throws Exception { Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { LolDataList dataList = new Gson().fromJson(body.string(), LolDataList.class); e.onNext(dataList); } } } }).subscribeOn(Schedulers.io()) .doOnNext(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { // 处理数据保存逻辑 } }) .flatMap(new Function&lt;LolDataList, ObservableSource&lt;LolDataList&gt;&gt;() { @Override public ObservableSource&lt;LolDataList&gt; apply(LolDataList lolDataList) throws Exception { Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); LolDataList dataList = null; if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { dataList = new Gson().fromJson(body.string(), LolDataList.class); } } Log.e(TAG, &quot;flatMap 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;); return Observable.just(dataList); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\\n&quot;+lolDataList.getData().size()); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(Throwable throwable) throws Exception { } }); 执行结果： 13 16:48:53.667 9180-9382/? E/RxCaseFlatMapActivity: create 线程:RxCachedThreadScheduler-2 07-13 16:48:54.104 9180-9382/? E/RxCaseFlatMapActivity: flatMap 线程:RxCachedThreadScheduler-2 07-13 16:48:54.105 9180-9180/? E/RxCaseFlatMapActivity: subscribe 线程:main6 间隔任务实现心跳mDisposable = Flowable.interval(1, TimeUnit.SECONDS) .doOnNext(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: doOnNext : &quot;+aLong ); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: 设置文本 ：&quot;+aLong ); mRxOperatorsText.append(&quot;accept: 设置文本 ：&quot;+aLong +&quot;\\n&quot;); } }); 结果： 07-14 11:01:19.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 0 07-14 11:01:19.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：0 07-14 11:01:20.048 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 1 07-14 11:01:20.050 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：1 07-14 11:01:21.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 2 07-14 11:01:21.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：2 07-14 11:01:22.049 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 3 07-14 11:01:22.051 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：3 资源链接RxJava文档中文版","categories":[{"name":"rxjava","slug":"rxjava","permalink":"http://yoursite.com/categories/rxjava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://yoursite.com/tags/RxJava/"}],"keywords":[{"name":"rxjava","slug":"rxjava","permalink":"http://yoursite.com/categories/rxjava/"}]},{"title":"hexo 个性化设置（大全）","slug":"Hexo美化","date":"2018-07-16T10:56:45.000Z","updated":"2018-07-20T14:29:06.000Z","comments":false,"path":"2018/07/16/Hexo美化/","link":"","permalink":"http://yoursite.com/2018/07/16/Hexo美化/","excerpt":"","text":"主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class=\"blockquote-center\"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: src1&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）123456789101112 .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 鼠标点击小红心的设置将 love.js 文件添加到 \\themes\\next\\source\\js\\src 文件目录下。找到 \\themes\\next\\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \\themes\\next\\source\\js\\src 文件目录下。找到 \\themes\\next\\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\\next\\source\\css_custom\\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置12345search: path: search.xml field: post format: html limit: 10000 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 加入动态背景首先找到\\themes\\next\\layout_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 1&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\" count=\"50\" zindex=\"-2\" opacity=\"1\" color=\"0,104,183\"&gt;&lt;/script&gt; 然后在themes\\source\\js\\src\\下新建文件particle.js写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(\"script\"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,\"zIndex\",-1),o:n(i,\"opacity\",.5),c:n(i,\"color\",\"0,0,0\"),n:n(i,\"count\",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=\"rgba(\"+m.c+\",\"+(t+.2)+\")\",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(\"canvas\"),m=t(),d=\"c_n\"+m.l,l=u.getContext(\"2d\"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=\"position:fixed;top:0;left:0;z-index:\"+m.z+\";opacity:\"+m.o,e(\"body\")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 修改字体大小打开\\themes\\next\\source\\css\\ _variables\\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base = 16px 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改 themes\\next\\source\\css_common\\components\\sidebar\\sidebar-author.styl123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; &lt;!-- (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();--&gt;&lt;/script&gt; 然后文章中添加：1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如:12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 加速访问HEXO修改博客所依赖的字体资源 打开 NexT 的主题配置文件「_config.yml」，找到如下图所示的字体设置区域，删除全局字体族「Lato」。 MakeDown语法123456789101112131415161718[hexo](http://www.baidu.com) 表示超链接##大标题###小标题&lt;!-- more --&gt;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125;blah blah blah&#123;% endcq %&#125;空格 中文全角空格表示---文章标题---&gt;内容 区块引用*1*2*3列表*内容* 表示强调内容![Alt text](/path/to/img.jpg) 图片![](/upload_image/20161012/1.png) 参考","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]},{"title":"Tinker 热补丁接入过程中的坑！！！","slug":"Tinker-接入","date":"2016-12-09T02:23:35.000Z","updated":"2018-07-19T13:56:15.000Z","comments":true,"path":"2016/12/09/Tinker-接入/","link":"","permalink":"http://yoursite.com/2016/12/09/Tinker-接入/","excerpt":"","text":"##Tinker 介绍 ##gradle 接入gradle是推荐的接入方式，在gradle插件tinker-patch-gradle-plugin中我们帮你完成proguard、multiDex以及Manifest处理等工作。 ##添加gradle依赖在项目的根目录build.gradle中，添加tinker-patch-gradle-plugin的依赖 引入tinker 核心库然后在baseUI-lib文件的build.gradle，我们需要添加tinker的库依赖以及apply tinker的gradle插件. 在APP/build.gradle 下面添加tinker 的配置文件 keep_in_main_dex.txt 文件内容就是指定你要放置到主DEX 中的类 -keep public class implements com.tencent.tinker.loader.app.ApplicationLifeCycle { ;} -keep public class extends com.tencent.tinker.loader.TinkerLoader { ;} -keep public class extends com.tencent.tinker.loader.app.TinkerApplication { } -keep class com.tencent.tinker.loader.* { ;} -keep class com.anzogame.corelib.GameApplication { *;} 运行APP 彩蛋….(Too many classes in –main-dex-list, main dex capacity exceeded) 为什么会这样子呢 ？ 我们已经采用了GOOGLE 的方案多DEX ,从报错上来看应该是主DEX 的类太多了，超过了限制，但是这个哪些类放到主DEX 不是我们决定的啊，很操蛋， 那么我们来看系统是如何分包的. ####在项目中，可以直接运行 gradle 的 task 。 collect{flavor}{buildType}MultiDexComponents Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 文件中去。 packageAll{flavor}DebugClassesForMultiDex Task 。该 task 是将所有类打包成 jar 文件存在 build/intermediates/multi-dex/{flavor}/debug/allclasses.jar 。 当 BuildType 为 Release 的时候，执行的是 proguard{flavor}Release Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 build/intermediates/classes-proguard/{flavor}/release/classes.jar shrink{flavor}{buildType}MultiDexComponents Task 。该 task 会根据 maindexlist.txt 生成 componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 build/intermediates/multi-dex/{flavor}/{buildType}/componentClasses.jar create{flavor}{buildType}MainDexClassList Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。 通过上面的流程我们可以得出 ，我们主DEX 中的类取决于build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中的内容 ，那么我们在执行MultiDexComponents task 时候做些拦截，把Activity 从主DEX中移除，这里面的移除不是全部移除，如果Activity中包含有子类，那么我们的移除是无效，还是会被放入到主DEX,另外，如果你 Application 、Service 、 Receiver 、 Provider 中的直接引用类还是会被放到第一个主DEX中。 当我们采用多DEX 的时候，应用启动的首先回加载主DEX ，其他的 dex 需要我们在应用启动后进行动态加载安装， 通过MultiDex.install(getApplication());加载其他DEX .Google 官方方案是如何加载的呢？ Google 官方支持 Multidex 的 jar 包是 android-support-multidex.jar，该 jar 包从 build tools 21.1 开始支持。这个 jar 加载 apk 中的从 dex 流程如下： 此处主要的工作就是从 apk 中提取出所有的从 dex（classes2.dex，classes3.dex，…），然后通过反射依次安装加载从 dex 并合并 DexPathList 的 Element 数组。 ##为什么API 21 以上就没有主DEX 过大的问题呢？ 这是为了5.0以上系统在安装过程中的art阶段就将所有的classes(..N).dex合并到一个单独的oat文件(5.0以下只能苦逼的启动时加载 对于Art相关知识，可以参考老罗的系列文章 传送门 ###DEX类分包的规则 我们开启多DEX支持一般是指定了multiDexEnabled，系统其实它利用的是Android sdk build tool中的mainDexClasses脚本，这在版本21以上才会有。使用方法非常很简单： mainDexClasses [–output ] 该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步：a. 环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。b. 使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。c. 通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表。 这里只是简单的得到所有入口类(即rules中的Instrumentation、application、Activity、Annotation等等)的直接引入类。何为直接引用类？在init过程，会在校验阶段去resolve它各个方法、变量引用到的类，这些类统称为某个类的直接引用类。举个栗子：12345public class MainActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState) &#123; DirectReferenceClass test = new DirectReferenceClass(); &#125;&#125; public class DirectReferenceClass { public DirectReferenceClass() { InDirectReferenceClass test = new InDirectReferenceClass(); }} public class InDirectReferenceClass { public InDirectReferenceClass() { }} 上面有MainActivity、DirectReferenceClass、InDirectReferenceClass三个类，其中DirectReferenceClass是MainActivity的直接引用类，InDirectReferenceClass是DirectReferenceClass的直接引用类。而InDirectReferenceClass是MainActivity的间接引用类(即直接引用类的所有直接引用类)。 对于5.0以下的系统，我们需要在启动时手动加载其他的dex。而我们并没有要求得到所有的间接引用类，这是因为我们在attachBaseContext的时候，已将其他dex加载。 事实上，若我们在attachBaseContext中调用Multidex.install，我们只需引入Application的直接引用类即可，mainDexClasses将Activity、ContentProvider、Service等的直接引用类也引入，主要是满足需要在非attachBaseContent加载多dex的需求。另一方面，若存在以下代码，将出现NoClassDefFoundError错误。 public class HelloMultiDexApplication extends Application { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); DirectReferenceClass test = new DirectReferenceClass(); MultiDex.install(this); }} 这是因为在实际运行过程中，DirectReferenceClass需要的InDirectReferenceClass并不一定在主dex。解决方法是手动将该类放于dx的-main-dex-list参数中： afterEvaluate { tasks.matching { it.name.startsWith(‘dex’) }.each { dx -&gt; if (dx.additionalParameters == null) { dx.additionalParameters = [] } dx.additionalParameters += ‘–multi-dex’ dx.additionalParameters += “–main-dex-list=$projectDir/“.toString() }} ##LinearAlloc 是什么 LinearAlloc 主要用来管理 Dalvik 中 class 加载时的内存，就是让 App 在执行时减少系统内存的占用。在 App 的安装过程中，系统会运行一个名为 dexopt 的程序为该应用在当前机型中运行做准备。dexopt 使用 LinearAlloc 来存储应用的方法信息。App 在执行前会将 class 读进 LinearAlloc 这个 buffer 中，这个 LinearAlloc 在 Android 2.3 之前是 4M 或 5M ，到 4.0 之后变为 8M 或 16M。因为 5M 实在是太小了，可能还没有 65536 就已经超过 5M 了，什么意思呢，就是只有一个包的情况下也有可能出现 INSTALL_FAILED_DEXOPT ，原因就在于 LinearAlloc。 ###解决 LinearAlloc DEXOPT &amp;&amp; DEX2OAT 是什么？ ###dexopt当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 apk路径 @ apk名 @ classes.dex 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。 更多可查看 Dalvik Optimization and Verification With dexopt 。 ####dex2oatAndroid Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。 更多可查看 Android运行时ART简要介绍和学习计划 。 ##Application Not Responding 因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 MultiDex.install() 操作是在 Application.attachBaseContext() 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 MultiDex.install() 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那又会 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。 引入dexnkife 核心库dexnkife 项目地址: DexKnifePlugin. dexnkife 帮助我们划分类到主DEX 首先在APP/目录下面新建dexknife.txt文件，用于配置dexknife ##在APP层添加Tinker的配置文件 ，配置文件如下： tinkerEnabled: tinker 的开关 ###tinker 多渠道打包怎么处理？tinker 本身是支持flavor 打包的： 加入上面的配置，执行assembleRelease task, 会在app/build/bakApk/目录下面生成所有flavor 中的渠道包. 接着修改代码和资源文件，执行tinkerPatchAllFlavorRelease 生成所有渠道的补丁包 然在后在手机上执行通渠道的补丁升级，可以正常升级，如果你用tencent渠道的包升级test 渠道的补丁包，就会失败，什么原因呢？查看tinker文档 额。。。。 实际使用中不可能对不同渠道进行补丁包的管理，多个渠道需要使用一个补丁包，那么我们就需要对我们现在有的打包方式进行修改，tinker 的建议方式原理和美团的快速打包方案类似，那么我们来看下美团的打包方案。 ###美团打包方案传送门1传送门2 ###第一步：修改我们的多渠道flavors 打包方式去掉所有渠道，只剩下一个test渠道做为基础渠道，然后在启动APP的时候动态设置渠道值，例如可以用友盟提供的方式AnalyticsConfig.setChannel(ChannelUtil.getChannel(getCurrentActivity()));动态设置渠道值获取渠道代码 ###第二步：替换我们之前的获取渠道名称代码 AndroidApiUtils.getUmengChannel(Context context) , 改为友盟提供的方式AnalyticsConfig.getChannel(getApplicationContext()) ，因为我们以前的代码是直接读取的meta 中的与友盟渠道号 ,查看友盟的代码，AnalyticsConfig.getChannel 是在渠道号不为空的情况下才会去读取meta 中的，我们打包方式是不会对AndroidManifest.xml 中的渠道号做替换的，只是内存中的channel 替换。 ###第三步：打包生成apk ，在把生成APK 放到脚本同级的目录下面，进入目录执行python MultiChannelBuildTool.py生成apk， 不到一分钟，所有渠道的APK 已经生成好了,channel.txt 是所有渠道的渠道列表。 下面是打包脚本: 按照美团的打包方式生成基础APK 多渠道APK 补丁包，经验证补丁可以正常运行。 以后发版本打包的流程， 执行gradle clean assembleRelease -PDEV_PACKET=false 任务，release 目录下面生成基础版本的APK ,然后在当前目录下面实行python MultiChannelBuildTool.py ，同时在release 同级目录下面会生成 bakApk/…/ 备份的apk ，mapping.txt, R.txt 文件。 ##热补丁接入相关疑问？ ###tinker 热补丁和DroidPlug插件有什么区别？tinker 是热更新工具 目前补丁不支持新增四大组件 DroidPlug 核心思想是hook 系统流程，占坑实现插件。 ###tinker 的资源是怎么修复的？ ###tinker 的DEX是怎么修复的？ ###tinker 的so是怎么修复的？ ###Android 中是怎么确认哪些类放到主DEX中的呢？ ##Tinker 相关文章微信Tinker的一切都在这里，包括源码(一) Android_N混合编译与对热补丁影响解析 微信Android热补丁实践演进之路","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"热补丁","slug":"热补丁","permalink":"http://yoursite.com/tags/热补丁/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]}]}