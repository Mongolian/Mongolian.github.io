<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 开源APP收集]]></title>
    <url>%2F2018%2F08%2F29%2Fandroid-%E5%BC%80%E6%BA%90APP%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[LeafPic ( Github | APK | 适用于: 初级开发者)LeafPic 是最好的开源图库APP，非常适合初级开发者学习，库中实现了动态主题的功能，可以好好研读一下啊 Simple Calendar (Github | APK | 适用于：初级开发者)这个应用完全基于 Kotlin 来开发的，如果你正在或打算学习 Kotlin 的话，这个项目是一个很好的应用，通过这个项目你还可以学习到定制Widget的方法 Amaze File Manager (Github | APK | 适用于：中级开发者)文件管理器应该是现在手机的标配了，通过这个项目你可以学习到如何处理手机上sdcard中的文件 Easy Sound Recorder (Github | APK | 适用于：初级开发者)通过这个项目你可以学习到关于Android平台录音的相关的信息，这个应用本省比较简单(只有一个主Activity)，这个应用是按照Material Design来设计的 MLManager (Github | APK | 适用于：初级开发者)通过这个项目学习到关于Android中安装应用的详细信息，以及安装卸载应用等相关的知识 PhotoAffix (Github | APK | 适用于：初级开发者)通过这个项目可以学习到Android开发相关的基础知识，能够进一步巩固自己的基础知识，学到关于定制View的相关的知识 MovieGuide (Github | APK | 适用于：中级开发者)这个项目使用了一些框架，想MVP，Clean Architecture， RxJava， Dagger2，可以更好的学习这个框架的使用情况 AnExplorer (Github | APK | 适用于：中级开发者)是一个文件管理器，兼容平板和手机，学习到文件处理，root管理，定制views等知识 Minimal ToDo (Github | APK | 适用于：初级开发者)学习Android相关的基础知识 Timber (Github | APK | 适用于：高级开发者)Timber是一个设计美观，功能丰富的音乐播放器，这个项目不太适合初级开发者，涉及到的内容比较多 AnotherMonitor (Github | APK | 适用于：中级开发者)监控Android的进程，内存使用，CPU使用情况等，工程简单易懂 InstaMaterial (Github | APK | 适用于：初级开发者)这个工程师学习Material Design的好项目，有大量的Material Design的元素、动画，可以在自己的应用中参考实现 CoCoin (Github | APK | 适用于：初级开发者)是一个个人视图记账的应用，有漂亮的UI设计，可以学习到处理数据，使用图表，定制View等 OmniNotes (Github | APK | 适用于：中级开发者)是像Evernote的一款笔记应用，还有大量的特性：分享，搜索，附件，视频，音频，时间提醒等功能 Clip Stack (Github | APK | 适用于：初级开发者)是管理复制粘贴管理的应用，可以了解到包的结构，应用架构，编码规范等知识，这个项目已经停止更新了 Super Clean Master (Github | APK | 适用于：高级开发者)和Clean master 功能类似的应用，用更简洁优雅的方式实现了相关的功能 Travel Mate (Github | APK | 适用于：中级开发者)是一款基于地理位置和地图的旅游应用 KISS (Github | APK | 适用于：中级开发者)轻量级的launcher,特点是简单，快速 Turbo Editor (Github | APK | 适用于：中级开发者)非常强大的文字编辑器，对不同的语言支持语法高亮，还可以打开大文件 Wally (Github | APK | 适用于：初级开发者)简单，快速，高效的壁纸应用，这个莹莹易于扩展和维护 Pedometer (Github | APK | 适用于：初级开发者)是一款计步软件，可以学习到传感器的相关知识 Antoxp2p 聊天软件]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin 基础知识]]></title>
    <url>%2F2018%2F08%2F26%2Fkotlin-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[kotlin 基础知识中文官方 kotlin官方sample 介绍基础语法（一）123456789101112fun getGreeting(): String &#123; val words = mutableListOf&lt;String&gt;() words.add("Hello,") words.add("world!") return words.joinToString(separator = " ")&#125;fun main(args: Array&lt;String&gt;) &#123; println(getGreeting())&#125;输出：hello world for 循环1234567891011121314151617fun testFor()&#123; val items = listOf("apple", "banana", "kiwifruit") for (item in items) &#123; println(item) &#125; for (index in items.indices)&#123; print("index is $index value is $&#123;items[index]&#125; \n") &#125;&#125;输出：applebananakiwifruitindex is 0 value is apple index is 1 value is banana index is 2 value is kiwifruit while 循环12345678910111213fun testWhile()&#123; val items = listOf("apple", "banana", "kiwifruit") var index = 0 while ( index &lt; items.size)&#123; println("items is $&#123;items[index]&#125;") index++ &#125;&#125;结果：items is appleitems is bananaitems is kiwifruit When 表达式 (java的switch)123456789fun testWhen( a : Int)&#123; when(a)&#123; 0, 1 -&gt; print("x == 0 or x == 1") 4 -&gt; println("x == 4") in 5..10 -&gt; println("x in 5 ..10") !in 100..200 -&gt; println("x !in 100..200") else -&gt; print("otherwise") &#125;&#125; 使用区间（range）123456789101112131415161718192021222324fun testRange()&#123; var i = 4 if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i) &#125; for (i in 1..4) print(i) println() for (i in 4 downTo 1) print(i) println() for (i in 1..10 step 2) print(i) println() for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 print(i) &#125;&#125;结果：41234432113579123456789 Maps 遍历12345678fun testMap()&#123; var maps = mutableMapOf&lt;String,String&gt;(); maps.put("key1","value1") maps.put("key2","value2") for ((k, v) in maps) &#123; println("$k -&gt; $v") &#125;&#125; 空安全123456789101112131415161718192021222324252627282930/** * 空安全 */fun testNull()&#123; // 编译错误，编译不通过，s 不能为空，// var s : String = "abc"// s = null // 便通过，s1 可以为空// var s1 : String? = "abc"// s1 = null// // 还是编译不通过，s1为空// print(s1.length) // 安全调用，b?.length 返回Null ,不会出异常// val a = "Kotlin"// val b: String? = null// println(b?.length)// println(a?.length) // !! 操作符 非空断言运算符 kotlin.KotlinNullPointerException var b : String? = null val l = b!!.length var data = 3 //当data不为空的时候，执行语句块 data?.let&#123; println("data is not null") &#125;&#125; Elvis 操作符1234567val l: Int = if (b != null) b.length else -1// 应用 ?: 表达式之后val l = b?.length ?: -1如果 ?: 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。 ####高阶函数与 lambda 表达式 基本类型1234567Type Bit widthDouble 64Float 32Long 64Int 32Short 16Byte 8 ###函数 1234567891011121314151617181920212223242526272829303132函数的声明：fun say(str: String): String &#123; return str&#125;简写：fun say(str: String): String = str在简化：fun say(str: String): str函数的默认参数：fun say(firstName: String = "Tao", lastName: String = "Zhang")&#123;&#125;变参函数：//在Java中，我们这么表示一个变长函数public boolean hasEmpty(String... strArray)&#123; for (String str : strArray)&#123; if ("".equals(str) || str == null) return true; &#125; return false;&#125;//在Kotlin中，使用关键字vararg来表示fun hasEmpty(vararg strArray: String?): Boolean&#123; for (str in strArray)&#123; if ("".equals(str) || str == null) return true &#125; return false&#125; 嵌套函数Kotlin 的函数有一些非常有意思的特性，比如函数中再声明函数。与内部类有些类似，内部函数可以直接访问外部函数的局部变量、常量，而外部函数同级的其他函数不能访问到内部函数。这种写法通常使用在 会在某些条件下触发递归的方法内或者是不希望外部其他函数访问到的函数，在一般情况下是不推荐使用嵌套函数的 1234567891011fun function() &#123; val str = "hello!" fun say(count: Int = 10) &#123; println(str) if (count &gt; 0) &#123; say(count - 1) &#125; &#125; say()&#125; 类构造函数 Kotlin 的构造函数可以写在类头中，跟在类名后面，如果有注解还需要加上关键字constructor。这种写法声明的构造函数，我们称之为主构造函数。例如下面我们为Person创建带一个String类型参数的构造函数。在构造函数中声明的参数，它们默认属于类的公有字段，可以直接使用，如果你不希望别的类访问到这个变量，可以用private修饰。在主构造函数中不能有任何代码实现，如果有额外的代码需要在构造方法中执行，你需要放到init代码块中执行。同时，在本示例中由于需要更改 name 参数的值，我们将 val 改为 var,表明 name 参数是一个可改变的参数。 123456789101112131415161718192021222324252627open class Person (private var name : String)&#123; private var description = ""; init &#123; name = "zlz" println("init $name") &#125; constructor( name : String , des : String) : this(name) &#123; this.description = des println("constructor $name") &#125; fun sayHello()&#123; println("sayHello name is $name , description is $description") &#125; var person = Person("hello","xiaoqiang") person.sayHello() 结果： init zlz constructor hello sayHello name is zlz , description is xiaoqiang&#125; 次级构造函数 一个类当然会有多个构造函数的可能，只有主构造函数可以写在类头中，其他的次级构造函数(Secondary Constructors)就需要写在类体中了。次级构造函数调用了主构造函数，完成 name 的赋值。由于次级构造函数不能直接将参数转换为字段，所以需要手动声明一个 description 字段，并为 description 字段赋值。 修饰符123456open 修饰符Kotlin 默认会为每个变量和方法添加 final 修饰符。这么做的目的是为了程序运行的性能，其实在 Java 程序中，你也应该尽可能为每个类添加final 为每个类加了final也就是说，在 Kotlin 中默认每个类都是不可被继承的。如果你确定这个类是会被继承的，那么你需要给这个类添加 open 修饰符。internal 修饰符Java 有三种访问修饰符，public/private/protected，还有一个默认的包级别访问权限没有修饰符。在 Kotlin 中，默认的访问权限是 public，也就是说不加访问权限修饰符的就是 public 的。而多增加了一种访问修饰符叫 internal。它是模块级别的访问权限。何为模块(module)，我们称被一起编译的一系列 Kotlin 文件为一个模块。在 IDEA 中可以很明确的看到一个 module 就是一个模块，当跨 module 的时候就无法访问另一个module 的 internal 变量或方法 枚举类Kotlin 与 Java 混编Java 转换为 KotlinIntellij IDEA 会帮你一键转换，将 Java 代码转换成 Kotlin 代码(但是反过来就不行了)。在 Mac 上，系统默认的快捷键为control+shift+command+K,快捷键可以通过你的编译器 keymap 中修改：command+, -&gt; 搜索keymap -&gt; 右侧搜索kotlin，可以查看到Convert Java File to Kotlin File项。 在 Kotlin 中调用 Java 代码1234567891011fun invokeJava(source: List&lt;Int&gt;)&#123; var calendar = Calendar.getInstance(); if (calendar.firstDayOfWeek == Calendar.SUNDAY) &#123; // 调用 getFirstDayOfWeek() calendar.firstDayOfWeek = Calendar.MONDAY // 调用ll setFirstDayOfWeek() &#125; if (!calendar.isLenient) &#123; // 调用 isLenient() calendar.isLenient = true // 调用 setLenient() &#125; &#125; Calendar.getInstance() 是Java中的类 返回 void 的方法 如果一个 Java 方法返回 void，那么从 Kotlin 调用时中返回 Unit。 万一有人使用其返回值，它将由 Kotlin 编译器在调用处赋值， 因为该值本身是预先知道的（是 Unit） #####将 Kotlin 中是关键字的 Java 标识符进行转义一些 Kotlin 关键字在 Java 中是有效标识符：in、 object、 is 等等。 如果一个 Java 库使用了 Kotlin 关键字作为方法，你仍然可以通过反引号（`）字符转义它来调用该方法： 123456789// Java 代码中有个方法叫 is()public void is()&#123; //...&#125;// 转换为 Kotlin 代码需要加反引号转义fun `is`() &#123; //...&#125; static 方法 在 Kotlin 中没有 static关键字,那么如果在 Java 代码中想要通过类名调用一个 Kotlin 类的方法，你需要给这个方法加入@JvmStatic注解（这个注解只在 jvm 平台有用）companion object表示外部类的一个伴生对象，你可以把他理解为外部类自动创建了一个对象作为自己的field 1234567891011121314151617写法一object StringUtils&#123; @JvmStatic fun isEmpty ( str : String) : Boolean&#123; return ""==str &#125;&#125;写法二class StringUtils &#123; companion object &#123; fun isEmpty(str: String): Boolean &#123; return "" == str &#125; &#125;&#125;StringUtils.isEmpty("hello");StringUtils.Companion.isEmpty("hello"); Java 中调用 Kotlin]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F24%2Fandroid-%E6%94%B6%E9%9B%86%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Android 收藏的开源项目]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bugly热补丁发布和使用]]></title>
    <url>%2F2018%2F08%2F16%2Fbugly%E7%83%AD%E8%A1%A5%E4%B8%81%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Bugly热补丁发布和使用精进课堂热补丁集成的bugly版本的热更新，bugly 则使用的是简化版本的tinker 。 bulgy 热补丁接入文档 tinker接入文档 打全渠道包通常我们执行gradle脚本 assembleReleaseChannels 命令打全渠道包，打包之前需要校验，versionName versionCode是否正确，目前tinkerId是和版本号绑定的也就是versionName, 比如，1.8.0版本，那么tinkerId也是1.8.0，tinkerId在 app/tinker-support.gradle 脚本中 tinkerId=globalConfig.getAt(“appVersionName”) 获取 上面生成的是按照时间来生成的基准包。 生成补丁包 首先修改tinker-support.gradle 脚本文件的baseApkDir ，改成我们刚才生成的bakApk日期 在AboutUsActivity 修改代码 执行生成热补丁脚本命令buildTinkerPatchRelease 命令生成补丁，补丁生成成功如下图 patch_signed_7zip.apk 是生成之后成功的经过7z压缩的补丁。 补丁生成之后随即选择一个渠道包进行安装，然后补丁包上床bugly 的热补丁发布平台上，进性测试发布，如果该版本目前没有线上用户，则可选择全量进行测试。 选择发布之后，启动之前安装的渠道包，在logcat中用tinker做关键字过滤，查看日志 这表示补丁已经下发成功到客户端，并且补丁本地合成成功，等待重启进程，退出应用或是关闭屏幕在开启，则会自动重启进程。 补丁合成成功。 本地安装补丁 在AboutUsActivity中initData 方法，有对本地SDCARD 上面的patch_signed_7zip.apk 补丁文件进行加载，测试补丁是否正确，只需要把生成好的补丁文件放到SDCARD 的根目录上面，然后打开关于页面，日志中看logcat 的tinker标签的日志来判断是否补丁成功。 12345 String path = Environment.getExternalStorageDirectory().getAbsolutePath() + "/patch_signed_7zip.apk";// File file = new File(path);// if(file.exists()) &#123;// Beta.applyTinkerPatch(getApplicationContext(), path);// &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>热补丁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handler消息机制源码解析（面试问题）]]></title>
    <url>%2F2018%2F07%2F21%2FAndroid-Handler-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[做Android的，应该都用过handler，handler是异步通信用的，用来解决耗时任务阻塞主线程的，耗时任务放到子线程去做，通过handler进行UI更新,handler 涉及 Message,MessageQueue,Looper ,如下图： MessageQueue]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 中的背压]]></title>
    <url>%2F2018%2F07%2F21%2FRxJava-%E8%83%8C%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[背压 backpressure 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略，或者说背压是流速控制的一种策略Backpressure 其实是一种现象：在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。 背压策略的一个前提是异步环境，也就是说，被观察者和观察者处在不同的线程环境中。 背压（Backpressure）并不是一个像flatMap一样可以在程序中直接使用的操作符，他只是一种控制事件流速的策略。 响应式拉取（reactive pull） 在RxJava的观察者模型中，被观察者是主动的推送数据给观察者，观察者是被动接收的。而响应式拉取则反过来，观察者主动从被观察者那里去拉取数据，而被观察者变成被动的等待通知再发送数据。 观察者可以根据自身实际情况按需拉取数据，而不是被动接收（也就相当于告诉上游观察者把速度慢下来），最终实现了上游被观察者发送事件的速度的控制，实现了背压的策略 RxJava 2.x 更新中，出现了两种观察者模式： Observable ( 被观察者 ) / Observer ( 观察者 ) Flowable （被观察者）/ Subscriber （观察者 RxJava 2.x 也为我们保留了简化订阅方法，我们可以根据需求，进行相应的简化订阅，只不过传入对象改为了 ConsumerConsumer 即消费者，用于接收单个值，BiConsumer 则是接收两个值. Hot and Cold ObservablesHot Observables 和cold Observables并不是严格的概念区分，它只是对于两类Observable形象的描述 Cold Observables：指的是那些在订阅之后才开始发送事件的Observable（每个Subscriber都能接收到完整的事件）。 Hot Observables:指的是那些在创建了Observable之后，（不管是否订阅）就开始发送事件的Observable 在1.0中我们一般使用的都是Cold Observable，除非特殊需求，才会使用Hot Observable,在这里，Hot Observable这一类是不支持背压的，而是Cold Observable这一类中也有一部分并不支持背压（比如interval，timer等操作符创建的Observable），都是Observable，结果有的支持背压，有的不支持，这就是RxJava1.X的一个问题，但在2.0中，这种问题已经解决了 背压例子以两根水管举例子: 之前我们所的上游和下游分别是Observable和Observer, 这次不一样的是上游变成了Flowable, 下游变成了Subscriber, 但是水管之间的连接还是通过subscribe(), 我们来看看最基本的用法吧: Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); } }, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); s.request(Long.MAX_VALUE); //注意这句代码 } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }; upstream.subscribe(downstream); 这段代码中,分别创建了一个上游Flowable和下游Subscriber, 上下游工作在同一个线程中, 执行结果： 07-20 16:30:29.642 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe 07-20 16:30:29.643 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 1 onNext: 1 07-20 16:30:29.644 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 2 onNext: 2 emit 3 onNext: 3 emit complete 07-20 16:30:29.645 7679-7679/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onComplete 在上面的代码中也有这么一句代码: s.request(Long.MAX_VALUE); 这句代码有什么用呢, 不要它可以吗? 我们来试试: 去掉这句这行结果： 07-20 16:35:47.474 12931-12931/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe 07-20 16:35:47.475 12931-12931/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 1 07-20 16:35:47.487 12931-12931/com.nanchen.rxjava2examples W/RxCaseBackPressActivity: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377) at com.nanchen.rxjava2examples.module.backpress.RxCaseBackPressActivity$1.subscribe(RxCaseBackPressActivity.java:194) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) at io.reactivex.Flowable.subscribe(Flowable.java:12986) at io.reactivex.Flowable.subscribe(Flowable.java:12935) at com.nanchen.rxjava2examples.module.backpress.RxCaseBackPressActivity.doSomething(RxCaseBackPressActivity.java:230) at com.nanchen.rxjava2examples.module.rxjava2.operators.item.RxOperatorBaseActivity.onViewClicked(RxOperatorBaseActivity.java:47) at com.nanchen.rxjava2examples.module.rxjava2.operators.item.RxOperatorBaseActivity_ViewBinding$1.doClick(RxOperatorBaseActivity_ViewBinding.java:38) at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22) at android.view.View.performClick(View.java:6303) at android.view.View$PerformClick.run(View.java:24828) at android.os.Handler.handleCallback(Handler.java:789) at android.os.Handler.dispatchMessage(Handler.java:98) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6798) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 07-20 16:35:47.487 12931-12931/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 2 emit 3 emit complete 刚刚发出了第一个请求，就抛出异常了， 为什么呢？首先第一个同步的代码, 为什么上游发送第一个事件后下游就抛出了MissingBackpressureException异常, 这是因为下游没有调用request, 上游就认为下游没有处理事件的能力, 而这又是一个同步的订阅, 既然下游处理不了, 那上游不可能一直等待吧, 如果是这样, 万一这两根水管工作在主线程里, 界面不就卡死了吗, 因此只能抛个异常来提醒我们 。 那异步线程会报错误么？ Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); } }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); 执行结果： 07-20 16:47:32.549 22878-22878/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe emit 1 07-20 16:47:32.550 22878-22878/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: emit 2 emit 3 emit complete 没有报异常，因为是异步，那么s.request(Long.MAX_VALUE); 什么意思呢，其实Flowable在设计的时候采用了一种新的思路也就是响应式拉取的方式来更好的解决上下游流速不均衡的问题，requeset 标识的是下游的处理能力， 下游能处理几个就告诉上游我要几个, 这样只要上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM. 异步线程中上游正确发送了所有事件？ 这是因为在Flowable里默认有一个大小为128的水缸, 当上下游工作在不同的线程中时, 上游就会先把事件发送到这个水缸中, 因此, 下游虽然没有调用request, 但是上游在水缸中保存着这些事件, 只有当下游调用request时, 才从水缸里取出事件发给下游. 验证一下: public static void request(long n) { mSubscription.request(n); //在外部调用request请求上游 } public static void demo3() { Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); } }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; //把Subscription保存起来 } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); } 在界面上增加了一个按钮, 点击一次就调用Subscription.request(1), 来看看运行结果: 上游的缓冲池有多大？ 答案是128 在Flowable源码里面可以找到 public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt; { /** The default buffer size. */ static final int BUFFER_SIZE; static { BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128)); } 测试一下： Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; i &lt; 128; i++) { Log.d(TAG, &quot;emit &quot; + i); emitter.onNext(i); } } }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); 执行结果： zlc.season.rxjava2demo D/TAG: onSubscribe zlc.season.rxjava2demo D/TAG: emit 0 ... zlc.season.rxjava2demo D/TAG: emit 126 zlc.season.rxjava2demo D/TAG: emit 127 zlc.season.rxjava2demo D/TAG: emit 128 //这是第129个事件 zlc.season.rxjava2demo W/TAG: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377) at zlc.season.rxjava2demo.demo.ChapterSeven$7.subscribe(ChapterSeven.java:169) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) at io.reactivex.Flowable.subscribe(Flowable.java:12218) at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761) 当缓冲池里面的内容大于128的时候一样的报异常，这时候就需要一个更大池子了，BackpressureStrategy.BUFFER这个策略下，这个池子没有上线，可以一直发，直到内存爆掉，不信看例子： Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; i &lt; 1000; i++) { Log.d(TAG, &quot;emit &quot; + i); emitter.onNext(i); } } }, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); 运行结果： zlc.season.rxjava2demo D/TAG: onSubscribe zlc.season.rxjava2demo D/TAG: emit 0 zlc.season.rxjava2demo D/TAG: emit 1 zlc.season.rxjava2demo D/TAG: emit 2 ... zlc.season.rxjava2demo D/TAG: emit 997 zlc.season.rxjava2demo D/TAG: emit 998 zlc.season.rxjava2demo D/TAG: emit 999 如果放开数量限制，无线次发送事件，最终会导致内存暴增直到爆掉，所以Flowable用不好就内存泄漏啦 BackpressureStrategy.DROP 策略Drop就是直接把存不下的事件丢弃 public static void request() { mSubscription.request(128); } public static void demo3() { Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; ; i++) { emitter.onNext(i); } } }, BackpressureStrategy.DROP).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); } 执行结果： FLowable内部的默认的水缸大小为128, 因此, 它刚开始肯定会把0-127这128个事件保存起来, 然后丢弃掉其余的事件, 当我们request(128)的时候,下游便会处理掉这128个事件, 那么上游水缸中又会重新装进新的128个事件 BackpressureStrategy.LATESTLatest就是只保留最新的事件. Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception { for (int i = 0; i &lt; 10000; i++) { //只发1w个事件 emitter.onNext(i); } } }, BackpressureStrategy.DROP).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); mSubscription = s; s.request(128); //一开始就处理掉128个事件 } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;onNext: &quot; + integer); } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); Latest的运行结果 从运行结果中可以看到, 除去前面128个事件, 与Drop不同, Latest总是能获取到最后最新的事件, 例如这里我们总是能获得最后一个事件9999. 关于FLowable的策略我们也讲完了, 这些FLowable是我自己创建的, 所以我可以选择策略, 那面对有些FLowable并不是我自己创建的, 该怎么办呢? 比如RxJava中的interval操作符, 这个操作符并不是我们自己创建的, 来看下面这个例子 Flowable.interval(1, TimeUnit.MICROSECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Long&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(TAG, &quot;onSubscribe&quot;); s.request(Long.MAX_VALUE); } @Override public void onNext(Long aLong) { Log.d(TAG, &quot;onNext: &quot; + aLong); try { Thread.sleep(1000); //延时1秒 } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void onError(Throwable t) { Log.w(TAG, &quot;onError: &quot;, t); } @Override public void onComplete() { Log.d(TAG, &quot;onComplete&quot;); } }); interval操作符发送Long型的事件, 从0开始, 每隔指定的时间就把数字加1并发送出来, 在这个例子里, 我们让它每隔1毫秒就发送一次事件, 在下游延时1秒去接收处理, 不用猜也知道结果是什么: 07-20 17:29:12.547 13561-13561/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onSubscribe 07-20 17:29:12.568 13561-13561/com.nanchen.rxjava2examples D/RxCaseBackPressActivity: onNext: 0 07-20 17:29:13.577 13561-13561/com.nanchen.rxjava2examples W/RxCaseBackPressActivity: onError: io.reactivex.exceptions.MissingBackpressureException: Can&apos;t deliver value 128 due to lack of requests at io.reactivex.internal.operators.flowable.FlowableInterval$IntervalSubscriber.run(FlowableInterval.java:87) at io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:39) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:457) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:307) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:302) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636) at java.lang.Thread.run(Thread.java:764) 07-20 17:29:13.578 13561-13561/com.nanchen.rxjava2examples I/Choreographer: Skipped 61 frames! The application may be doing too much work on its main thread. 错误信息比较明显，缓冲池子超过了128 了，不能deliver了，呵呵，其实RxJava给我们提供了其他的方法，策略和上面的一样 onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest()]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 个性化设置（大全）]]></title>
    <url>%2F2018%2F07%2F16%2FHexo%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: src1&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）123456789101112 .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置12345search: path: search.xml field: post format: html limit: 10000 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 加入动态背景首先找到\themes\next\layout_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 1&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在themes\source\js\src\下新建文件particle.js写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示：1$font-size-base = 16px 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改 themes\next\source\css_common\components\sidebar\sidebar-author.styl123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; &lt;!-- (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();--&gt;&lt;/script&gt; 然后文章中添加：1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如:12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 加速访问HEXO修改博客所依赖的字体资源 打开 NexT 的主题配置文件「_config.yml」，找到如下图所示的字体设置区域，删除全局字体族「Lato」。 MakeDown语法123456789101112131415161718[hexo](http://www.baidu.com) 表示超链接##大标题###小标题&lt;!-- more --&gt;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125;blah blah blah&#123;% endcq %&#125;空格 中文全角空格表示---文章标题---&gt;内容 区块引用*1*2*3列表*内容* 表示强调内容![Alt text](/path/to/img.jpg) 图片![](/upload_image/20161012/1.png) 参考]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava基本使用]]></title>
    <url>%2F2018%2F07%2F16%2FRxJava%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你 RxJava是什么?开源地址 RxAndroid 要知道RxJava是什么，那么你应该先去了解一下Rx。Rx的全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。Rx已经渗透到了各个语言中，有了Rx所以才有了 RxJava，Rx.NET、RxJS、RxSwift、Rx.rb、RxPHP等等 官方描述 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库） RXJava 是基于观察者模式构建的 我们先把观察者模式说清楚 例如：“按下开关，台灯灯亮” 在这个事件中，台灯作为观察者，开关作为被观察者，台灯透过电线来观察开关的状态来并做出相应的处理 开关（被观察者）作为事件的产生方（生产“开”和“关”这两个事件），是主动的，是整个开灯事理流程的起点。 台灯（观察者）作为事件的处理方（处理“灯亮”和“灯灭”这两个事件），是被动的，是整个开灯事件流程的终点。 在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的（上图没有体现，后面对会讲到）。 响应式编程是什么？ 响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。 RxJava好在哪？例如：从服务器上拉去最新小区列表的需求，可能这样写：12345678910111213141516171819202122new Thread() &#123; @Override public void run() &#123; super.run(); //从服务端获取小区列表 List&lt;Community&gt; communities = getCommunitiesFromServer(); for (Community community : communities) &#123; List&lt;House&gt; houses = community.houses; for (House house : houses) &#123; if (house.price &gt;= 5000000) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); &#125; &#125; &#125; &#125; &#125;.start(); RxJava 这样写：1234567891011121314151617181920Observable.from(getCommunitiesFromServer()) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.houses); &#125; &#125;).filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.price&gt;=5000000; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); Lambda 简化：12345Observable.from(getCommunitiesFromServer()) .flatMap(community -&gt; Observable.from(community.houses)) .filter(house -&gt; house.price&gt;=5000000).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::addHouseInformationToScreen); RxJava基本元素RxJava基本使用操作符Create create 操作符应该是最常见的操作符了，主要用于产生一个 Obserable 被观察者对象，为了方便大家的认知，以后的教程中统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e(TAG, "Observable emit 1" + "\n"); e.onNext(1); Log.e(TAG, "Observable emit 2" + "\n"); e.onNext(2); Log.e(TAG, "Observable emit 3" + "\n"); e.onNext(3); e.onComplete(); Log.e(TAG, "Observable emit 4" + "\n" ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.e(TAG, "onSubscribe : " + d.isDisposed() + "\n" ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; Log.e(TAG, "onNext : value : " + integer + "\n" ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); Log.e(TAG, "onNext : isDisposable : " + mDisposable.isDisposed() + "\n"); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.e(TAG, "onError : value : " + e.getMessage() + "\n" ); &#125; @Override public void onComplete() &#123; Log.e(TAG, "onComplete" + "\n" ); &#125; &#125;); 结果： 12345678onSubscribe : falseObservable emit 1onNext : value : 1Observable emit 2onNext : value : 2onNext : isDisposable : trueObservable emit 3Observable emit 4 Map 它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return "This is result " + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append("accept : " + s +"\n"); Log.e(TAG, "accept : " + s +"\n" ); &#125; &#125;); 结果： 12307-10 14:15:49.857 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 107-10 14:15:49.859 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 207-10 14:15:49.861 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 3 Concat简单来说就是连接两个或多个发射器，向一个发射器一样，他们不产生交叉 Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;concat : &quot;+ integer + &quot;\n&quot; ); } }); 执行结果： 07-10 14:24:10.147 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 1 07-10 14:24:10.150 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 2 07-10 14:24:10.154 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 3 07-10 14:24:10.158 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 4 07-10 14:24:10.162 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 5 07-10 14:24:10.166 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 6 FlatMap transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\n&quot;); } }); 结果： ConcatMap concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证吧 Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\n&quot;); } }); 执行结果： Distinct顾名思义，去重操作符 Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\n&quot;); } }); 执行结果： Filter emit only those items from an Observable that pass a predicate test Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() { @Override public boolean test(@NonNull Integer integer) throws Exception { return integer &gt;= 10; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;filter : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;filter : &quot; + integer + &quot;\n&quot;); } }); 结果： just就是一个简单的发射器依次调用 onNext() 方法。 Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { mRxOperatorsText.append(&quot;accept : onNext : &quot; + s + &quot;\n&quot;); Log.e(TAG,&quot;accept : onNext : &quot; + s + &quot;\n&quot; ); } }); 结果： buffer periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a timebuffer 操作符接受两个参数，buffer(count,skip)，作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。 Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() { @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception { mRxOperatorsText.append(&quot;buffer size : &quot; + integers.size() + &quot;\n&quot;); Log.e(TAG, &quot;buffer size : &quot; + integers.size() + &quot;\n&quot;); mRxOperatorsText.append(&quot;buffer value : &quot;); Log.e(TAG, &quot;buffer value : &quot; ); for (Integer i : integers) { mRxOperatorsText.append(i + &quot;&quot;); Log.e(TAG, i + &quot;&quot;); } mRxOperatorsText.append(&quot;\n&quot;); Log.e(TAG, &quot;\n&quot;); } }); 结果： timer create an Observable that emits a particular item after a given delay Log.e(TAG, &quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); } }); 输出： Interval create an Observable that emits a sequence of integers spaced by a given time interval Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); } }); 输出： skip suppress the first n items emitted by an Observable 代表跳过 count 个数目开始接收。 Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;skip : &quot;+integer + &quot;\n&quot;); Log.e(TAG, &quot;skip : &quot;+integer + &quot;\n&quot;); } }); 结果： take emit only the first n items emitted by an Observable 接受一个 long 型参数 count ，代表至多接收 count 个数据 Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;take : &quot;+integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: take : &quot;+integer + &quot;\n&quot; ); } }); 结果： Debounce only emit an item from an Observable if a particular timespan has passed without it emitting another item Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception { // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); } }).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;debounce :&quot; + integer + &quot;\n&quot;); Log.e(TAG,&quot;debounce :&quot; + integer + &quot;\n&quot;); } }); 结果： last emit only the last item (or the last item that meets some condition) emitted by an Observable last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 Observable.just(1, 2, 3) .last(4) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;last : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;last : &quot; + integer + &quot;\n&quot;); } }); 结果： merge combine multiple Observables into one by merging their emissions merge 顾名思义，熟悉版本控制工具的你一定不会不知道 merge 命令，而在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。 Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;merge :&quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: merge :&quot; + integer + &quot;\n&quot; ); } }); 结果： reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;reduce : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: reduce : &quot; + integer + &quot;\n&quot;); } }); 结果： scan apply a function to each item emitted by an Observable, sequentially, and emit each successive value scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;scan &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: scan &quot; + integer + &quot;\n&quot;); } }); 结果： zip combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/&quot;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()).build(); LolInterface lolInterfaceRequest = retrofit.create(LolInterface.class); Observable&lt;LolDataList&gt; observable1 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable&lt;LolDataList&gt; observable2 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;LolDataList, LolDataList, String&gt;() { @Override public String apply(@NonNull LolDataList lolDataList, @NonNull LolDataList lolDataList2) throws Exception { return &quot;合并后的数据为 lolDataList1=&quot;+lolDataList.getData().get(0).getDisplayName() + &quot;,lolDataList2=&quot;+lolDataList2.getData().get(0).getDisplayName(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;accept: 成功：&quot; + s+&quot;\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;accept: 失败：&quot; + throwable+&quot;\n&quot;); } }); 结果： accept: 成功：合并后的数据为 lolDataList1=灭世魔神 诺提勒斯,lolDataList2=灭世魔神 诺提勒斯 subScribeOn 指定的就是发射事件的线程 多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略 observeOn 指定的就是订阅者接收事件的线程。 多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次 线程切换Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); e.onNext(1); e.onComplete(); } }).subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(mainThread)，Current thread is &quot; + Thread.currentThread().getName()); } }) .observeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(io)，Current thread is &quot; + Thread.currentThread().getName()); } }); 结果： 07-14 11:43:11.669 8550-8611/com.nanchen.rxjava2examples E/RxThreadActivity: Observable thread is : RxNewThreadScheduler-1 07-14 11:43:11.670 8550-8550/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(mainThread)，Current thread is main 07-14 11:43:11.671 8550-8612/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(io)，Current thread is RxCachedThreadScheduler-2 场景举例 一个简单的网络请求 Observable.create(new ObservableOnSubscribe&lt;Response&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Response&gt; e) throws Exception { Builder builder = new Builder() .url(&quot;http://api.avatardata.cn/MobilePlace/LookUp?key=ec47b85086be4dc8b5d941f5abd37a4e&amp;mobileNumber=13021671512&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); Response response = call.execute(); e.onNext(response); Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); } }).map(new Function&lt;Response, MobileAddress&gt;() { @Override public MobileAddress apply(@NonNull Response response) throws Exception { Log.e(TAG, &quot;map 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { Log.e(TAG, &quot;map:转换前:&quot; + response.body()); return new Gson().fromJson(body.string(), MobileAddress.class); } } return null; } }).observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress s) throws Exception { Log.e(TAG, &quot;doOnNext 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Log.e(TAG, &quot;doOnNext: 保存成功：&quot; + s.toString() + &quot;\n&quot;); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress data) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Log.e(TAG, &quot;成功:&quot; + data.toString() + &quot;\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Log.e(TAG, &quot;失败：&quot; + throwable.getMessage() + &quot;\n&quot;); } }); 执行结果： 07-13 09:13:08.664 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: map 线程:RxCachedThreadScheduler-1 map:转换前:okhttp3.internal.http.RealResponseBody@3e17a0f 07-13 09:13:08.691 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: create 线程:RxCachedThreadScheduler-1 07-13 09:13:08.691 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext 线程:main 07-13 09:13:08.702 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext: 保存成功：MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 07-13 09:13:08.737 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: subscribe 线程:main 07-13 09:13:08.741 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: 成功:MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 多个网络请求串行执行Observable.create(new ObservableOnSubscribe&lt;LolDataList&gt;() { @Override public void subscribe(ObservableEmitter&lt;LolDataList&gt; e) throws Exception { Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { LolDataList dataList = new Gson().fromJson(body.string(), LolDataList.class); e.onNext(dataList); } } } }).subscribeOn(Schedulers.io()) .doOnNext(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { // 处理数据保存逻辑 } }) .flatMap(new Function&lt;LolDataList, ObservableSource&lt;LolDataList&gt;&gt;() { @Override public ObservableSource&lt;LolDataList&gt; apply(LolDataList lolDataList) throws Exception { Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); LolDataList dataList = null; if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { dataList = new Gson().fromJson(body.string(), LolDataList.class); } } Log.e(TAG, &quot;flatMap 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); return Observable.just(dataList); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;+lolDataList.getData().size()); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(Throwable throwable) throws Exception { } }); 执行结果： 13 16:48:53.667 9180-9382/? E/RxCaseFlatMapActivity: create 线程:RxCachedThreadScheduler-2 07-13 16:48:54.104 9180-9382/? E/RxCaseFlatMapActivity: flatMap 线程:RxCachedThreadScheduler-2 07-13 16:48:54.105 9180-9180/? E/RxCaseFlatMapActivity: subscribe 线程:main6 间隔任务实现心跳mDisposable = Flowable.interval(1, TimeUnit.SECONDS) .doOnNext(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: doOnNext : &quot;+aLong ); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: 设置文本 ：&quot;+aLong ); mRxOperatorsText.append(&quot;accept: 设置文本 ：&quot;+aLong +&quot;\n&quot;); } }); 结果： 07-14 11:01:19.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 0 07-14 11:01:19.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：0 07-14 11:01:20.048 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 1 07-14 11:01:20.050 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：1 07-14 11:01:21.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 2 07-14 11:01:21.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：2 07-14 11:01:22.049 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 3 07-14 11:01:22.051 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：3 资源链接RxJava文档中文版]]></content>
      <categories>
        <category>rxjava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tinker 热补丁接入过程中的坑！！！]]></title>
    <url>%2F2016%2F12%2F09%2FTinker-%E6%8E%A5%E5%85%A5%2F</url>
    <content type="text"><![CDATA[##Tinker 介绍 ##gradle 接入gradle是推荐的接入方式，在gradle插件tinker-patch-gradle-plugin中我们帮你完成proguard、multiDex以及Manifest处理等工作。 ##添加gradle依赖在项目的根目录build.gradle中，添加tinker-patch-gradle-plugin的依赖 引入tinker 核心库然后在baseUI-lib文件的build.gradle，我们需要添加tinker的库依赖以及apply tinker的gradle插件. 在APP/build.gradle 下面添加tinker 的配置文件 keep_in_main_dex.txt 文件内容就是指定你要放置到主DEX 中的类 -keep public class implements com.tencent.tinker.loader.app.ApplicationLifeCycle { ;} -keep public class extends com.tencent.tinker.loader.TinkerLoader { ;} -keep public class extends com.tencent.tinker.loader.app.TinkerApplication { } -keep class com.tencent.tinker.loader.* { ;} -keep class com.anzogame.corelib.GameApplication { *;} 运行APP 彩蛋….(Too many classes in –main-dex-list, main dex capacity exceeded) 为什么会这样子呢 ？ 我们已经采用了GOOGLE 的方案多DEX ,从报错上来看应该是主DEX 的类太多了，超过了限制，但是这个哪些类放到主DEX 不是我们决定的啊，很操蛋， 那么我们来看系统是如何分包的. ####在项目中，可以直接运行 gradle 的 task 。 collect{flavor}{buildType}MultiDexComponents Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 文件中去。 packageAll{flavor}DebugClassesForMultiDex Task 。该 task 是将所有类打包成 jar 文件存在 build/intermediates/multi-dex/{flavor}/debug/allclasses.jar 。 当 BuildType 为 Release 的时候，执行的是 proguard{flavor}Release Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 build/intermediates/classes-proguard/{flavor}/release/classes.jar shrink{flavor}{buildType}MultiDexComponents Task 。该 task 会根据 maindexlist.txt 生成 componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 build/intermediates/multi-dex/{flavor}/{buildType}/componentClasses.jar create{flavor}{buildType}MainDexClassList Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。 通过上面的流程我们可以得出 ，我们主DEX 中的类取决于build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中的内容 ，那么我们在执行MultiDexComponents task 时候做些拦截，把Activity 从主DEX中移除，这里面的移除不是全部移除，如果Activity中包含有子类，那么我们的移除是无效，还是会被放入到主DEX,另外，如果你 Application 、Service 、 Receiver 、 Provider 中的直接引用类还是会被放到第一个主DEX中。 当我们采用多DEX 的时候，应用启动的首先回加载主DEX ，其他的 dex 需要我们在应用启动后进行动态加载安装， 通过MultiDex.install(getApplication());加载其他DEX .Google 官方方案是如何加载的呢？ Google 官方支持 Multidex 的 jar 包是 android-support-multidex.jar，该 jar 包从 build tools 21.1 开始支持。这个 jar 加载 apk 中的从 dex 流程如下： 此处主要的工作就是从 apk 中提取出所有的从 dex（classes2.dex，classes3.dex，…），然后通过反射依次安装加载从 dex 并合并 DexPathList 的 Element 数组。 ##为什么API 21 以上就没有主DEX 过大的问题呢？ 这是为了5.0以上系统在安装过程中的art阶段就将所有的classes(..N).dex合并到一个单独的oat文件(5.0以下只能苦逼的启动时加载 对于Art相关知识，可以参考老罗的系列文章 传送门 ###DEX类分包的规则 我们开启多DEX支持一般是指定了multiDexEnabled，系统其实它利用的是Android sdk build tool中的mainDexClasses脚本，这在版本21以上才会有。使用方法非常很简单： mainDexClasses [–output ] 该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步：a. 环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。b. 使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。c. 通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表。 这里只是简单的得到所有入口类(即rules中的Instrumentation、application、Activity、Annotation等等)的直接引入类。何为直接引用类？在init过程，会在校验阶段去resolve它各个方法、变量引用到的类，这些类统称为某个类的直接引用类。举个栗子：12345public class MainActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState) &#123; DirectReferenceClass test = new DirectReferenceClass(); &#125;&#125; public class DirectReferenceClass { public DirectReferenceClass() { InDirectReferenceClass test = new InDirectReferenceClass(); }} public class InDirectReferenceClass { public InDirectReferenceClass() { }} 上面有MainActivity、DirectReferenceClass、InDirectReferenceClass三个类，其中DirectReferenceClass是MainActivity的直接引用类，InDirectReferenceClass是DirectReferenceClass的直接引用类。而InDirectReferenceClass是MainActivity的间接引用类(即直接引用类的所有直接引用类)。 对于5.0以下的系统，我们需要在启动时手动加载其他的dex。而我们并没有要求得到所有的间接引用类，这是因为我们在attachBaseContext的时候，已将其他dex加载。 事实上，若我们在attachBaseContext中调用Multidex.install，我们只需引入Application的直接引用类即可，mainDexClasses将Activity、ContentProvider、Service等的直接引用类也引入，主要是满足需要在非attachBaseContent加载多dex的需求。另一方面，若存在以下代码，将出现NoClassDefFoundError错误。 public class HelloMultiDexApplication extends Application { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); DirectReferenceClass test = new DirectReferenceClass(); MultiDex.install(this); }} 这是因为在实际运行过程中，DirectReferenceClass需要的InDirectReferenceClass并不一定在主dex。解决方法是手动将该类放于dx的-main-dex-list参数中： afterEvaluate { tasks.matching { it.name.startsWith(‘dex’) }.each { dx -&gt; if (dx.additionalParameters == null) { dx.additionalParameters = [] } dx.additionalParameters += ‘–multi-dex’ dx.additionalParameters += “–main-dex-list=$projectDir/“.toString() }} ##LinearAlloc 是什么 LinearAlloc 主要用来管理 Dalvik 中 class 加载时的内存，就是让 App 在执行时减少系统内存的占用。在 App 的安装过程中，系统会运行一个名为 dexopt 的程序为该应用在当前机型中运行做准备。dexopt 使用 LinearAlloc 来存储应用的方法信息。App 在执行前会将 class 读进 LinearAlloc 这个 buffer 中，这个 LinearAlloc 在 Android 2.3 之前是 4M 或 5M ，到 4.0 之后变为 8M 或 16M。因为 5M 实在是太小了，可能还没有 65536 就已经超过 5M 了，什么意思呢，就是只有一个包的情况下也有可能出现 INSTALL_FAILED_DEXOPT ，原因就在于 LinearAlloc。 ###解决 LinearAlloc DEXOPT &amp;&amp; DEX2OAT 是什么？ ###dexopt当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 apk路径 @ apk名 @ classes.dex 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。 更多可查看 Dalvik Optimization and Verification With dexopt 。 ####dex2oatAndroid Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。 更多可查看 Android运行时ART简要介绍和学习计划 。 ##Application Not Responding 因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 MultiDex.install() 操作是在 Application.attachBaseContext() 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 MultiDex.install() 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那又会 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。 引入dexnkife 核心库dexnkife 项目地址: DexKnifePlugin. dexnkife 帮助我们划分类到主DEX 首先在APP/目录下面新建dexknife.txt文件，用于配置dexknife ##在APP层添加Tinker的配置文件 ，配置文件如下： tinkerEnabled: tinker 的开关 ###tinker 多渠道打包怎么处理？tinker 本身是支持flavor 打包的： 加入上面的配置，执行assembleRelease task, 会在app/build/bakApk/目录下面生成所有flavor 中的渠道包. 接着修改代码和资源文件，执行tinkerPatchAllFlavorRelease 生成所有渠道的补丁包 然在后在手机上执行通渠道的补丁升级，可以正常升级，如果你用tencent渠道的包升级test 渠道的补丁包，就会失败，什么原因呢？查看tinker文档 额。。。。 实际使用中不可能对不同渠道进行补丁包的管理，多个渠道需要使用一个补丁包，那么我们就需要对我们现在有的打包方式进行修改，tinker 的建议方式原理和美团的快速打包方案类似，那么我们来看下美团的打包方案。 ###美团打包方案传送门1传送门2 ###第一步：修改我们的多渠道flavors 打包方式去掉所有渠道，只剩下一个test渠道做为基础渠道，然后在启动APP的时候动态设置渠道值，例如可以用友盟提供的方式AnalyticsConfig.setChannel(ChannelUtil.getChannel(getCurrentActivity()));动态设置渠道值获取渠道代码 ###第二步：替换我们之前的获取渠道名称代码 AndroidApiUtils.getUmengChannel(Context context) , 改为友盟提供的方式AnalyticsConfig.getChannel(getApplicationContext()) ，因为我们以前的代码是直接读取的meta 中的与友盟渠道号 ,查看友盟的代码，AnalyticsConfig.getChannel 是在渠道号不为空的情况下才会去读取meta 中的，我们打包方式是不会对AndroidManifest.xml 中的渠道号做替换的，只是内存中的channel 替换。 ###第三步：打包生成apk ，在把生成APK 放到脚本同级的目录下面，进入目录执行python MultiChannelBuildTool.py生成apk， 不到一分钟，所有渠道的APK 已经生成好了,channel.txt 是所有渠道的渠道列表。 下面是打包脚本: 按照美团的打包方式生成基础APK 多渠道APK 补丁包，经验证补丁可以正常运行。 以后发版本打包的流程， 执行gradle clean assembleRelease -PDEV_PACKET=false 任务，release 目录下面生成基础版本的APK ,然后在当前目录下面实行python MultiChannelBuildTool.py ，同时在release 同级目录下面会生成 bakApk/…/ 备份的apk ，mapping.txt, R.txt 文件。 ##热补丁接入相关疑问？ ###tinker 热补丁和DroidPlug插件有什么区别？tinker 是热更新工具 目前补丁不支持新增四大组件 DroidPlug 核心思想是hook 系统流程，占坑实现插件。 ###tinker 的资源是怎么修复的？ ###tinker 的DEX是怎么修复的？ ###tinker 的so是怎么修复的？ ###Android 中是怎么确认哪些类放到主DEX中的呢？ ##Tinker 相关文章微信Tinker的一切都在这里，包括源码(一) Android_N混合编译与对热补丁影响解析 微信Android热补丁实践演进之路]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>热补丁</tag>
      </tags>
  </entry>
</search>
