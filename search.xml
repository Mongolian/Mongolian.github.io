<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo 个性化设置]]></title>
    <url>%2F2018%2F07%2F16%2FHexo%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: src1&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面）123456789101112 .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置12345search: path: search.xml field: post format: html limit: 10000 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 MakeDown语法12345678910111213141516171819[hexo](http://www.baidu.com) 表示超链接##大标题###小标题&lt;!-- more --&gt;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125;blah blah blah&#123;% endcq %&#125;空格 中文全角空格表示---文章标题---&gt;内容 区块引用*1*2*3"```"列表*内容* 表示强调内容![Alt text](/path/to/img.jpg) 图片![](/upload_image/20161012/1.png)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava基本使用]]></title>
    <url>%2F2018%2F07%2F16%2FRxJava%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你 RxJava是什么?开源地址 RxAndroid 要知道RxJava是什么，那么你应该先去了解一下Rx。Rx的全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。Rx已经渗透到了各个语言中，有了Rx所以才有了 RxJava，Rx.NET、RxJS、RxSwift、Rx.rb、RxPHP等等 官方描述 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库） RXJava 是基于观察者模式构建的 我们先把观察者模式说清楚 例如：“按下开关，台灯灯亮” 在这个事件中，台灯作为观察者，开关作为被观察者，台灯透过电线来观察开关的状态来并做出相应的处理 开关（被观察者）作为事件的产生方（生产“开”和“关”这两个事件），是主动的，是整个开灯事理流程的起点。 台灯（观察者）作为事件的处理方（处理“灯亮”和“灯灭”这两个事件），是被动的，是整个开灯事件流程的终点。 在起点和终点之间，即事件传递的过程中是可以被加工，过滤，转换，合并等等方式处理的（上图没有体现，后面对会讲到）。 响应式编程是什么？ 响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。 RxJava好在哪？例如：从服务器上拉去最新小区列表的需求，可能这样写：12345678910111213141516171819202122new Thread() &#123; @Override public void run() &#123; super.run(); //从服务端获取小区列表 List&lt;Community&gt; communities = getCommunitiesFromServer(); for (Community community : communities) &#123; List&lt;House&gt; houses = community.houses; for (House house : houses) &#123; if (house.price &gt;= 5000000) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); &#125; &#125; &#125; &#125; &#125;.start(); RxJava 这样写：1234567891011121314151617181920Observable.from(getCommunitiesFromServer()) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.houses); &#125; &#125;).filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.price&gt;=5000000; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //将房子的信息添加到屏幕上 addHouseInformationToScreen(house); &#125; &#125;); Lambda 简化：12345Observable.from(getCommunitiesFromServer()) .flatMap(community -&gt; Observable.from(community.houses)) .filter(house -&gt; house.price&gt;=5000000).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::addHouseInformationToScreen); RxJava基本元素RxJava基本使用操作符Create create 操作符应该是最常见的操作符了，主要用于产生一个 Obserable 被观察者对象，为了方便大家的认知，以后的教程中统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e(TAG, "Observable emit 1" + "\n"); e.onNext(1); Log.e(TAG, "Observable emit 2" + "\n"); e.onNext(2); Log.e(TAG, "Observable emit 3" + "\n"); e.onNext(3); e.onComplete(); Log.e(TAG, "Observable emit 4" + "\n" ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; Log.e(TAG, "onSubscribe : " + d.isDisposed() + "\n" ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; Log.e(TAG, "onNext : value : " + integer + "\n" ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); Log.e(TAG, "onNext : isDisposable : " + mDisposable.isDisposed() + "\n"); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; Log.e(TAG, "onError : value : " + e.getMessage() + "\n" ); &#125; @Override public void onComplete() &#123; Log.e(TAG, "onComplete" + "\n" ); &#125; &#125;); 结果： 12345678onSubscribe : falseObservable emit 1onNext : value : 1Observable emit 2onNext : value : 2onNext : isDisposable : trueObservable emit 3Observable emit 4 Map 它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return "This is result " + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append("accept : " + s +"\n"); Log.e(TAG, "accept : " + s +"\n" ); &#125; &#125;); 结果： 12307-10 14:15:49.857 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 107-10 14:15:49.859 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 207-10 14:15:49.861 26872-26872/com.nanchen.rxjava2examples E/RxMapActivity: accept : This is result 3 Concat简单来说就是连接两个或多个发射器，向一个发射器一样，他们不产生交叉 Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;concat : &quot;+ integer + &quot;\n&quot; ); } }); 执行结果： 07-10 14:24:10.147 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 1 07-10 14:24:10.150 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 2 07-10 14:24:10.154 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 3 07-10 14:24:10.158 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 4 07-10 14:24:10.162 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 5 07-10 14:24:10.166 26872-26872/com.nanchen.rxjava2examples E/RxConcatActivity: concat : 6 FlatMap transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\n&quot;); } }); 结果： ConcatMap concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证吧 Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); } }).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() { @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { list.add(&quot;I am value &quot; + integer); } int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\n&quot;); } }); 执行结果： Distinct顾名思义，去重操作符 Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\n&quot;); } }); 执行结果： Filter emit only those items from an Observable that pass a predicate test Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() { @Override public boolean test(@NonNull Integer integer) throws Exception { return integer &gt;= 10; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;filter : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;filter : &quot; + integer + &quot;\n&quot;); } }); 结果： just就是一个简单的发射器依次调用 onNext() 方法。 Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { mRxOperatorsText.append(&quot;accept : onNext : &quot; + s + &quot;\n&quot;); Log.e(TAG,&quot;accept : onNext : &quot; + s + &quot;\n&quot; ); } }); 结果： buffer periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a timebuffer 操作符接受两个参数，buffer(count,skip)，作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。 Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() { @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception { mRxOperatorsText.append(&quot;buffer size : &quot; + integers.size() + &quot;\n&quot;); Log.e(TAG, &quot;buffer size : &quot; + integers.size() + &quot;\n&quot;); mRxOperatorsText.append(&quot;buffer value : &quot;); Log.e(TAG, &quot;buffer value : &quot; ); for (Integer i : integers) { mRxOperatorsText.append(i + &quot;&quot;); Log.e(TAG, i + &quot;&quot;); } mRxOperatorsText.append(&quot;\n&quot;); Log.e(TAG, &quot;\n&quot;); } }); 结果： timer create an Observable that emits a particular item after a given delay Log.e(TAG, &quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); } }); 输出： Interval create an Observable that emits a sequence of integers spaced by a given time interval Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\n&quot;); } }); 输出： skip suppress the first n items emitted by an Observable 代表跳过 count 个数目开始接收。 Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;skip : &quot;+integer + &quot;\n&quot;); Log.e(TAG, &quot;skip : &quot;+integer + &quot;\n&quot;); } }); 结果： take emit only the first n items emitted by an Observable 接受一个 long 型参数 count ，代表至多接收 count 个数据 Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;take : &quot;+integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: take : &quot;+integer + &quot;\n&quot; ); } }); 结果： Debounce only emit an item from an Observable if a particular timespan has passed without it emitting another item Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception { // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); } }).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;debounce :&quot; + integer + &quot;\n&quot;); Log.e(TAG,&quot;debounce :&quot; + integer + &quot;\n&quot;); } }); 结果： last emit only the last item (or the last item that meets some condition) emitted by an Observable last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 Observable.just(1, 2, 3) .last(4) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;last : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;last : &quot; + integer + &quot;\n&quot;); } }); 结果： merge combine multiple Observables into one by merging their emissions merge 顾名思义，熟悉版本控制工具的你一定不会不知道 merge 命令，而在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。 Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;merge :&quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: merge :&quot; + integer + &quot;\n&quot; ); } }); 结果： reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;reduce : &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: reduce : &quot; + integer + &quot;\n&quot;); } }); 结果： scan apply a function to each item emitted by an Observable, sequentially, and emit each successive value scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() { @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception { return integer + integer2; } }).subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { mRxOperatorsText.append(&quot;scan &quot; + integer + &quot;\n&quot;); Log.e(TAG, &quot;accept: scan &quot; + integer + &quot;\n&quot;); } }); 结果： zip combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/&quot;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()).build(); LolInterface lolInterfaceRequest = retrofit.create(LolInterface.class); Observable&lt;LolDataList&gt; observable1 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable&lt;LolDataList&gt; observable2 = lolInterfaceRequest.reqLolData().subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;LolDataList, LolDataList, String&gt;() { @Override public String apply(@NonNull LolDataList lolDataList, @NonNull LolDataList lolDataList2) throws Exception { return &quot;合并后的数据为 lolDataList1=&quot;+lolDataList.getData().get(0).getDisplayName() + &quot;,lolDataList2=&quot;+lolDataList2.getData().get(0).getDisplayName(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(@NonNull String s) throws Exception { Log.e(TAG, &quot;accept: 成功：&quot; + s+&quot;\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;accept: 失败：&quot; + throwable+&quot;\n&quot;); } }); 结果： accept: 成功：合并后的数据为 lolDataList1=灭世魔神 诺提勒斯,lolDataList2=灭世魔神 诺提勒斯 subScribeOn 指定的就是发射事件的线程 多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略 observeOn 指定的就是订阅者接收事件的线程。 多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次 线程切换Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception { Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName()); e.onNext(1); e.onComplete(); } }).subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(mainThread)，Current thread is &quot; + Thread.currentThread().getName()); } }) .observeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() { @Override public void accept(@NonNull Integer integer) throws Exception { Log.e(TAG, &quot;After observeOn(io)，Current thread is &quot; + Thread.currentThread().getName()); } }); 结果： 07-14 11:43:11.669 8550-8611/com.nanchen.rxjava2examples E/RxThreadActivity: Observable thread is : RxNewThreadScheduler-1 07-14 11:43:11.670 8550-8550/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(mainThread)，Current thread is main 07-14 11:43:11.671 8550-8612/com.nanchen.rxjava2examples E/RxThreadActivity: After observeOn(io)，Current thread is RxCachedThreadScheduler-2 场景举例 一个简单的网络请求 Observable.create(new ObservableOnSubscribe&lt;Response&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Response&gt; e) throws Exception { Builder builder = new Builder() .url(&quot;http://api.avatardata.cn/MobilePlace/LookUp?key=ec47b85086be4dc8b5d941f5abd37a4e&amp;mobileNumber=13021671512&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); Response response = call.execute(); e.onNext(response); Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); } }).map(new Function&lt;Response, MobileAddress&gt;() { @Override public MobileAddress apply(@NonNull Response response) throws Exception { Log.e(TAG, &quot;map 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { Log.e(TAG, &quot;map:转换前:&quot; + response.body()); return new Gson().fromJson(body.string(), MobileAddress.class); } } return null; } }).observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress s) throws Exception { Log.e(TAG, &quot;doOnNext 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Log.e(TAG, &quot;doOnNext: 保存成功：&quot; + s.toString() + &quot;\n&quot;); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;MobileAddress&gt;() { @Override public void accept(@NonNull MobileAddress data) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Log.e(TAG, &quot;成功:&quot; + data.toString() + &quot;\n&quot;); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(@NonNull Throwable throwable) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Log.e(TAG, &quot;失败：&quot; + throwable.getMessage() + &quot;\n&quot;); } }); 执行结果： 07-13 09:13:08.664 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: map 线程:RxCachedThreadScheduler-1 map:转换前:okhttp3.internal.http.RealResponseBody@3e17a0f 07-13 09:13:08.691 16010-16578/com.nanchen.rxjava2examples E/RxNetSingleActivity: create 线程:RxCachedThreadScheduler-1 07-13 09:13:08.691 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext 线程:main 07-13 09:13:08.702 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: doOnNext: 保存成功：MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 07-13 09:13:08.737 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: subscribe 线程:main 07-13 09:13:08.741 16010-16010/com.nanchen.rxjava2examples E/RxNetSingleActivity: 成功:MobileAddress{error_code=10005, reason=&apos;应用未审核超时，请提交认证&apos;, result=null} 多个网络请求串行执行Observable.create(new ObservableOnSubscribe&lt;LolDataList&gt;() { @Override public void subscribe(ObservableEmitter&lt;LolDataList&gt; e) throws Exception { Log.e(TAG, &quot;create 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { LolDataList dataList = new Gson().fromJson(body.string(), LolDataList.class); e.onNext(dataList); } } } }).subscribeOn(Schedulers.io()) .doOnNext(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { // 处理数据保存逻辑 } }) .flatMap(new Function&lt;LolDataList, ObservableSource&lt;LolDataList&gt;&gt;() { @Override public ObservableSource&lt;LolDataList&gt; apply(LolDataList lolDataList) throws Exception { Request.Builder builder = new Request.Builder() .url(&quot;http://lol.zhangyoubao.com/apis/rest/RolesService/new_paper_skin?roleid=19&amp;i_=863472021700411&amp;t_=1433993799448&amp;p_=30689&amp;v_=400500&amp;a_=lol&amp;pkg_=com.anzogame.lol&amp;d_=android&amp;osv_=16&amp;cha=TEST&amp;u_=&amp;&quot;) .get(); Request request = builder.build(); Call call = new OkHttpClient().newCall(request); okhttp3.Response response = call.execute(); LolDataList dataList = null; if (response.isSuccessful()) { ResponseBody body = response.body(); if (body != null) { dataList = new Gson().fromJson(body.string(), LolDataList.class); } } Log.e(TAG, &quot;flatMap 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;); return Observable.just(dataList); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;LolDataList&gt;() { @Override public void accept(LolDataList lolDataList) throws Exception { Log.e(TAG, &quot;subscribe 线程:&quot; + Thread.currentThread().getName() + &quot;\n&quot;+lolDataList.getData().size()); } }, new Consumer&lt;Throwable&gt;() { @Override public void accept(Throwable throwable) throws Exception { } }); 执行结果： 13 16:48:53.667 9180-9382/? E/RxCaseFlatMapActivity: create 线程:RxCachedThreadScheduler-2 07-13 16:48:54.104 9180-9382/? E/RxCaseFlatMapActivity: flatMap 线程:RxCachedThreadScheduler-2 07-13 16:48:54.105 9180-9180/? E/RxCaseFlatMapActivity: subscribe 线程:main6 间隔任务实现心跳mDisposable = Flowable.interval(1, TimeUnit.SECONDS) .doOnNext(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: doOnNext : &quot;+aLong ); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() { @Override public void accept(@NonNull Long aLong) throws Exception { Log.e(TAG, &quot;accept: 设置文本 ：&quot;+aLong ); mRxOperatorsText.append(&quot;accept: 设置文本 ：&quot;+aLong +&quot;\n&quot;); } }); 结果： 07-14 11:01:19.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 0 07-14 11:01:19.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：0 07-14 11:01:20.048 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 1 07-14 11:01:20.050 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：1 07-14 11:01:21.050 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 2 07-14 11:01:21.052 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：2 07-14 11:01:22.049 7399-7660/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: doOnNext : 3 07-14 11:01:22.051 7399-7399/com.nanchen.rxjava2examples E/RxCaseIntervalActivity: accept: 设置文本 ：3 资源链接RxJava文档中文版]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tinker 热补丁接入过程中的坑！！！]]></title>
    <url>%2F2016%2F12%2F09%2FTinker-%E6%8E%A5%E5%85%A5%2F</url>
    <content type="text"><![CDATA[##Tinker 介绍 ##gradle 接入gradle是推荐的接入方式，在gradle插件tinker-patch-gradle-plugin中我们帮你完成proguard、multiDex以及Manifest处理等工作。 ##添加gradle依赖在项目的根目录build.gradle中，添加tinker-patch-gradle-plugin的依赖 引入tinker 核心库然后在baseUI-lib文件的build.gradle，我们需要添加tinker的库依赖以及apply tinker的gradle插件. 在APP/build.gradle 下面添加tinker 的配置文件 keep_in_main_dex.txt 文件内容就是指定你要放置到主DEX 中的类 -keep public class implements com.tencent.tinker.loader.app.ApplicationLifeCycle { ;} -keep public class extends com.tencent.tinker.loader.TinkerLoader { ;} -keep public class extends com.tencent.tinker.loader.app.TinkerApplication { } -keep class com.tencent.tinker.loader.* { ;} -keep class com.anzogame.corelib.GameApplication { *;} 运行APP 彩蛋….(Too many classes in –main-dex-list, main dex capacity exceeded) 为什么会这样子呢 ？ 我们已经采用了GOOGLE 的方案多DEX ,从报错上来看应该是主DEX 的类太多了，超过了限制，但是这个哪些类放到主DEX 不是我们决定的啊，很操蛋， 那么我们来看系统是如何分包的. ####在项目中，可以直接运行 gradle 的 task 。 collect{flavor}{buildType}MultiDexComponents Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 文件中去。 packageAll{flavor}DebugClassesForMultiDex Task 。该 task 是将所有类打包成 jar 文件存在 build/intermediates/multi-dex/{flavor}/debug/allclasses.jar 。 当 BuildType 为 Release 的时候，执行的是 proguard{flavor}Release Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 build/intermediates/classes-proguard/{flavor}/release/classes.jar shrink{flavor}{buildType}MultiDexComponents Task 。该 task 会根据 maindexlist.txt 生成 componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 build/intermediates/multi-dex/{flavor}/{buildType}/componentClasses.jar create{flavor}{buildType}MainDexClassList Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。 通过上面的流程我们可以得出 ，我们主DEX 中的类取决于build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt 中的内容 ，那么我们在执行MultiDexComponents task 时候做些拦截，把Activity 从主DEX中移除，这里面的移除不是全部移除，如果Activity中包含有子类，那么我们的移除是无效，还是会被放入到主DEX,另外，如果你 Application 、Service 、 Receiver 、 Provider 中的直接引用类还是会被放到第一个主DEX中。 当我们采用多DEX 的时候，应用启动的首先回加载主DEX ，其他的 dex 需要我们在应用启动后进行动态加载安装， 通过MultiDex.install(getApplication());加载其他DEX .Google 官方方案是如何加载的呢？ Google 官方支持 Multidex 的 jar 包是 android-support-multidex.jar，该 jar 包从 build tools 21.1 开始支持。这个 jar 加载 apk 中的从 dex 流程如下： 此处主要的工作就是从 apk 中提取出所有的从 dex（classes2.dex，classes3.dex，…），然后通过反射依次安装加载从 dex 并合并 DexPathList 的 Element 数组。 ##为什么API 21 以上就没有主DEX 过大的问题呢？ 这是为了5.0以上系统在安装过程中的art阶段就将所有的classes(..N).dex合并到一个单独的oat文件(5.0以下只能苦逼的启动时加载 对于Art相关知识，可以参考老罗的系列文章 传送门 ###DEX类分包的规则 我们开启多DEX支持一般是指定了multiDexEnabled，系统其实它利用的是Android sdk build tool中的mainDexClasses脚本，这在版本21以上才会有。使用方法非常很简单： mainDexClasses [–output ] 该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步：a. 环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。b. 使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。c. 通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表。 这里只是简单的得到所有入口类(即rules中的Instrumentation、application、Activity、Annotation等等)的直接引入类。何为直接引用类？在init过程，会在校验阶段去resolve它各个方法、变量引用到的类，这些类统称为某个类的直接引用类。举个栗子：12345public class MainActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState) &#123; DirectReferenceClass test = new DirectReferenceClass(); &#125;&#125; public class DirectReferenceClass { public DirectReferenceClass() { InDirectReferenceClass test = new InDirectReferenceClass(); }} public class InDirectReferenceClass { public InDirectReferenceClass() { }} 上面有MainActivity、DirectReferenceClass、InDirectReferenceClass三个类，其中DirectReferenceClass是MainActivity的直接引用类，InDirectReferenceClass是DirectReferenceClass的直接引用类。而InDirectReferenceClass是MainActivity的间接引用类(即直接引用类的所有直接引用类)。 对于5.0以下的系统，我们需要在启动时手动加载其他的dex。而我们并没有要求得到所有的间接引用类，这是因为我们在attachBaseContext的时候，已将其他dex加载。 事实上，若我们在attachBaseContext中调用Multidex.install，我们只需引入Application的直接引用类即可，mainDexClasses将Activity、ContentProvider、Service等的直接引用类也引入，主要是满足需要在非attachBaseContent加载多dex的需求。另一方面，若存在以下代码，将出现NoClassDefFoundError错误。 public class HelloMultiDexApplication extends Application { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); DirectReferenceClass test = new DirectReferenceClass(); MultiDex.install(this); }} 这是因为在实际运行过程中，DirectReferenceClass需要的InDirectReferenceClass并不一定在主dex。解决方法是手动将该类放于dx的-main-dex-list参数中： afterEvaluate { tasks.matching { it.name.startsWith(‘dex’) }.each { dx -&gt; if (dx.additionalParameters == null) { dx.additionalParameters = [] } dx.additionalParameters += ‘–multi-dex’ dx.additionalParameters += “–main-dex-list=$projectDir/“.toString() }} ##LinearAlloc 是什么 LinearAlloc 主要用来管理 Dalvik 中 class 加载时的内存，就是让 App 在执行时减少系统内存的占用。在 App 的安装过程中，系统会运行一个名为 dexopt 的程序为该应用在当前机型中运行做准备。dexopt 使用 LinearAlloc 来存储应用的方法信息。App 在执行前会将 class 读进 LinearAlloc 这个 buffer 中，这个 LinearAlloc 在 Android 2.3 之前是 4M 或 5M ，到 4.0 之后变为 8M 或 16M。因为 5M 实在是太小了，可能还没有 65536 就已经超过 5M 了，什么意思呢，就是只有一个包的情况下也有可能出现 INSTALL_FAILED_DEXOPT ，原因就在于 LinearAlloc。 ###解决 LinearAlloc DEXOPT &amp;&amp; DEX2OAT 是什么？ ###dexopt当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 apk路径 @ apk名 @ classes.dex 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。 更多可查看 Dalvik Optimization and Verification With dexopt 。 ####dex2oatAndroid Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。 更多可查看 Android运行时ART简要介绍和学习计划 。 ##Application Not Responding 因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 MultiDex.install() 操作是在 Application.attachBaseContext() 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 MultiDex.install() 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那又会 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。 引入dexnkife 核心库dexnkife 项目地址: DexKnifePlugin. dexnkife 帮助我们划分类到主DEX 首先在APP/目录下面新建dexknife.txt文件，用于配置dexknife ##在APP层添加Tinker的配置文件 ，配置文件如下： tinkerEnabled: tinker 的开关 ###tinker 多渠道打包怎么处理？tinker 本身是支持flavor 打包的： 加入上面的配置，执行assembleRelease task, 会在app/build/bakApk/目录下面生成所有flavor 中的渠道包. 接着修改代码和资源文件，执行tinkerPatchAllFlavorRelease 生成所有渠道的补丁包 然在后在手机上执行通渠道的补丁升级，可以正常升级，如果你用tencent渠道的包升级test 渠道的补丁包，就会失败，什么原因呢？查看tinker文档 额。。。。 实际使用中不可能对不同渠道进行补丁包的管理，多个渠道需要使用一个补丁包，那么我们就需要对我们现在有的打包方式进行修改，tinker 的建议方式原理和美团的快速打包方案类似，那么我们来看下美团的打包方案。 ###美团打包方案传送门1传送门2 ###第一步：修改我们的多渠道flavors 打包方式去掉所有渠道，只剩下一个test渠道做为基础渠道，然后在启动APP的时候动态设置渠道值，例如可以用友盟提供的方式AnalyticsConfig.setChannel(ChannelUtil.getChannel(getCurrentActivity()));动态设置渠道值获取渠道代码 ###第二步：替换我们之前的获取渠道名称代码 AndroidApiUtils.getUmengChannel(Context context) , 改为友盟提供的方式AnalyticsConfig.getChannel(getApplicationContext()) ，因为我们以前的代码是直接读取的meta 中的与友盟渠道号 ,查看友盟的代码，AnalyticsConfig.getChannel 是在渠道号不为空的情况下才会去读取meta 中的，我们打包方式是不会对AndroidManifest.xml 中的渠道号做替换的，只是内存中的channel 替换。 ###第三步：打包生成apk ，在把生成APK 放到脚本同级的目录下面，进入目录执行python MultiChannelBuildTool.py生成apk， 不到一分钟，所有渠道的APK 已经生成好了,channel.txt 是所有渠道的渠道列表。 下面是打包脚本: 按照美团的打包方式生成基础APK 多渠道APK 补丁包，经验证补丁可以正常运行。 以后发版本打包的流程， 执行gradle clean assembleRelease -PDEV_PACKET=false 任务，release 目录下面生成基础版本的APK ,然后在当前目录下面实行python MultiChannelBuildTool.py ，同时在release 同级目录下面会生成 bakApk/…/ 备份的apk ，mapping.txt, R.txt 文件。 ##热补丁接入相关疑问？ ###tinker 热补丁和DroidPlug插件有什么区别？tinker 是热更新工具 目前补丁不支持新增四大组件 DroidPlug 核心思想是hook 系统流程，占坑实现插件。 ###tinker 的资源是怎么修复的？ ###tinker 的DEX是怎么修复的？ ###tinker 的so是怎么修复的？ ###Android 中是怎么确认哪些类放到主DEX中的呢？ ##Tinker 相关文章微信Tinker的一切都在这里，包括源码(一) Android_N混合编译与对热补丁影响解析 微信Android热补丁实践演进之路]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
